// ignore_for_file: always_specify_types
// ignore_for_file: camel_case_types
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_import

// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
// ignore_for_file: type=lint
@ffi.DefaultAsset('package:unnu_sap/src/tts/bindings.dart')
library;

import 'dart:ffi' as ffi;

@ffi.Native<ffi.Void Function(ffi.Pointer<va_list>)>()
external void __va_start(
  ffi.Pointer<va_list> arg0,
);

@ffi.Native<ffi.Void Function()>()
external void __security_init_cookie();

@ffi.Native<ffi.Void Function(ffi.UintPtr)>()
external void __security_check_cookie(
  int _StackCookie,
);

@ffi.Native<ffi.Void Function(ffi.UintPtr)>()
external void __report_gsfailure(
  int _StackCookie,
);

@ffi.Native<ffi.UintPtr>()
external int __security_cookie;

/// Please don't free the returned pointer.
/// Please don't modify the memory pointed by the returned pointer.
///
/// The memory pointed by the returned pointer is statically allocated.
///
/// Example return value: "1.12.1"
@ffi.Native<ffi.Pointer<ffi.Char> Function()>()
external ffi.Pointer<ffi.Char> SherpaOnnxGetVersionStr();

/// Please don't free the returned pointer.
/// Please don't modify the memory pointed by the returned pointer.
///
/// The memory pointed by the returned pointer is statically allocated.
///
/// Example return value: "6982b86c"
@ffi.Native<ffi.Pointer<ffi.Char> Function()>()
external ffi.Pointer<ffi.Char> SherpaOnnxGetGitSha1();

/// Please don't free the returned pointer.
/// Please don't modify the memory pointed by the returned pointer.
///
/// The memory pointed by the returned pointer is statically allocated.
///
/// Example return value: "Fri Jun 20 11:22:52 2025"
@ffi.Native<ffi.Pointer<ffi.Char> Function()>()
external ffi.Pointer<ffi.Char> SherpaOnnxGetGitDate();

/// @param config  Config for the recognizer.
/// @return Return a pointer to the recognizer. The user has to invoke
/// SherpaOnnxDestroyOnlineRecognizer() to free it to avoid memory leak.
@ffi.Native<
    ffi.Pointer<SherpaOnnxOnlineRecognizer> Function(
        ffi.Pointer<SherpaOnnxOnlineRecognizerConfig>)>()
external ffi.Pointer<SherpaOnnxOnlineRecognizer>
    SherpaOnnxCreateOnlineRecognizer(
  ffi.Pointer<SherpaOnnxOnlineRecognizerConfig> config,
);

/// Free a pointer returned by SherpaOnnxCreateOnlineRecognizer()
///
/// @param p A pointer returned by SherpaOnnxCreateOnlineRecognizer()
@ffi.Native<ffi.Void Function(ffi.Pointer<SherpaOnnxOnlineRecognizer>)>()
external void SherpaOnnxDestroyOnlineRecognizer(
  ffi.Pointer<SherpaOnnxOnlineRecognizer> recognizer,
);

/// Create an online stream for accepting wave samples.
///
/// @param recognizer  A pointer returned by SherpaOnnxCreateOnlineRecognizer()
/// @return Return a pointer to an OnlineStream. The user has to invoke
/// SherpaOnnxDestroyOnlineStream() to free it to avoid memory leak.
@ffi.Native<
    ffi.Pointer<SherpaOnnxOnlineStream> Function(
        ffi.Pointer<SherpaOnnxOnlineRecognizer>)>()
external ffi.Pointer<SherpaOnnxOnlineStream> SherpaOnnxCreateOnlineStream(
  ffi.Pointer<SherpaOnnxOnlineRecognizer> recognizer,
);

/// Create an online stream for accepting wave samples with the specified hot
/// words.
///
/// @param recognizer  A pointer returned by SherpaOnnxCreateOnlineRecognizer()
/// @return Return a pointer to an OnlineStream. The user has to invoke
/// SherpaOnnxDestroyOnlineStream() to free it to avoid memory leak.
@ffi.Native<
    ffi.Pointer<SherpaOnnxOnlineStream> Function(
        ffi.Pointer<SherpaOnnxOnlineRecognizer>, ffi.Pointer<ffi.Char>)>()
external ffi.Pointer<SherpaOnnxOnlineStream>
    SherpaOnnxCreateOnlineStreamWithHotwords(
  ffi.Pointer<SherpaOnnxOnlineRecognizer> recognizer,
  ffi.Pointer<ffi.Char> hotwords,
);

/// Destroy an online stream.
///
/// @param stream A pointer returned by SherpaOnnxCreateOnlineStream()
@ffi.Native<ffi.Void Function(ffi.Pointer<SherpaOnnxOnlineStream>)>()
external void SherpaOnnxDestroyOnlineStream(
  ffi.Pointer<SherpaOnnxOnlineStream> stream,
);

/// Accept input audio samples and compute the features.
/// The user has to invoke SherpaOnnxDecodeOnlineStream() to run the neural
/// network and decoding.
///
/// @param stream  A pointer returned by SherpaOnnxCreateOnlineStream().
/// @param sample_rate  Sample rate of the input samples. If it is different
/// from config.feat_config.sample_rate, we will do
/// resampling inside sherpa-onnx.
/// @param samples A pointer to a 1-D array containing audio samples.
/// The range of samples has to be normalized to [-1, 1].
/// @param n  Number of elements in the samples array.
@ffi.Native<
    ffi.Void Function(ffi.Pointer<SherpaOnnxOnlineStream>, ffi.Int32,
        ffi.Pointer<ffi.Float>, ffi.Int32)>()
external void SherpaOnnxOnlineStreamAcceptWaveform(
  ffi.Pointer<SherpaOnnxOnlineStream> stream,
  int sample_rate,
  ffi.Pointer<ffi.Float> samples,
  int n,
);

/// Return 1 if there are enough number of feature frames for decoding.
/// Return 0 otherwise.
///
/// @param recognizer  A pointer returned by SherpaOnnxCreateOnlineRecognizer
/// @param stream  A pointer returned by SherpaOnnxCreateOnlineStream
@ffi.Native<
    ffi.Int32 Function(ffi.Pointer<SherpaOnnxOnlineRecognizer>,
        ffi.Pointer<SherpaOnnxOnlineStream>)>()
external int SherpaOnnxIsOnlineStreamReady(
  ffi.Pointer<SherpaOnnxOnlineRecognizer> recognizer,
  ffi.Pointer<SherpaOnnxOnlineStream> stream,
);

/// Call this function to run the neural network model and decoding.
///
/// Precondition for this function: SherpaOnnxIsOnlineStreamReady() MUST
/// return 1.
///
/// Usage example:
///
/// while (SherpaOnnxIsOnlineStreamReady(recognizer, stream)) {
/// SherpaOnnxDecodeOnlineStream(recognizer, stream);
/// }
@ffi.Native<
    ffi.Void Function(ffi.Pointer<SherpaOnnxOnlineRecognizer>,
        ffi.Pointer<SherpaOnnxOnlineStream>)>()
external void SherpaOnnxDecodeOnlineStream(
  ffi.Pointer<SherpaOnnxOnlineRecognizer> recognizer,
  ffi.Pointer<SherpaOnnxOnlineStream> stream,
);

/// This function is similar to SherpaOnnxDecodeOnlineStream(). It decodes
/// multiple OnlineStream in parallel.
///
/// Caution: The caller has to ensure each OnlineStream is ready, i.e.,
/// SherpaOnnxIsOnlineStreamReady() for that stream should return 1.
///
/// @param recognizer  A pointer returned by SherpaOnnxCreateOnlineRecognizer()
/// @param streams  A pointer array containing pointers returned by
/// SherpaOnnxCreateOnlineRecognizer()
/// @param n  Number of elements in the given streams array.
@ffi.Native<
    ffi.Void Function(ffi.Pointer<SherpaOnnxOnlineRecognizer>,
        ffi.Pointer<ffi.Pointer<SherpaOnnxOnlineStream>>, ffi.Int32)>()
external void SherpaOnnxDecodeMultipleOnlineStreams(
  ffi.Pointer<SherpaOnnxOnlineRecognizer> recognizer,
  ffi.Pointer<ffi.Pointer<SherpaOnnxOnlineStream>> streams,
  int n,
);

/// Get the decoding results so far for an OnlineStream.
///
/// @param recognizer A pointer returned by SherpaOnnxCreateOnlineRecognizer().
/// @param stream A pointer returned by SherpaOnnxCreateOnlineStream().
/// @return A pointer containing the result. The user has to invoke
/// SherpaOnnxDestroyOnlineRecognizerResult() to free the returned
/// pointer to avoid memory leak.
@ffi.Native<
    ffi.Pointer<SherpaOnnxOnlineRecognizerResult> Function(
        ffi.Pointer<SherpaOnnxOnlineRecognizer>,
        ffi.Pointer<SherpaOnnxOnlineStream>)>()
external ffi.Pointer<SherpaOnnxOnlineRecognizerResult>
    SherpaOnnxGetOnlineStreamResult(
  ffi.Pointer<SherpaOnnxOnlineRecognizer> recognizer,
  ffi.Pointer<SherpaOnnxOnlineStream> stream,
);

/// Destroy the pointer returned by SherpaOnnxGetOnlineStreamResult().
///
/// @param r A pointer returned by SherpaOnnxGetOnlineStreamResult()
@ffi.Native<ffi.Void Function(ffi.Pointer<SherpaOnnxOnlineRecognizerResult>)>()
external void SherpaOnnxDestroyOnlineRecognizerResult(
  ffi.Pointer<SherpaOnnxOnlineRecognizerResult> r,
);

/// Return the result as a json string.
/// The user has to invoke
/// SherpaOnnxDestroyOnlineStreamResultJson()
/// to free the returned pointer to avoid memory leak
@ffi.Native<
    ffi.Pointer<ffi.Char> Function(ffi.Pointer<SherpaOnnxOnlineRecognizer>,
        ffi.Pointer<SherpaOnnxOnlineStream>)>()
external ffi.Pointer<ffi.Char> SherpaOnnxGetOnlineStreamResultAsJson(
  ffi.Pointer<SherpaOnnxOnlineRecognizer> recognizer,
  ffi.Pointer<SherpaOnnxOnlineStream> stream,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<ffi.Char>)>()
external void SherpaOnnxDestroyOnlineStreamResultJson(
  ffi.Pointer<ffi.Char> s,
);

/// SherpaOnnxOnlineStreamReset an OnlineStream , which clears the neural
/// network model state and the state for decoding.
///
/// @param recognizer A pointer returned by SherpaOnnxCreateOnlineRecognizer().
/// @param stream A pointer returned by SherpaOnnxCreateOnlineStream
@ffi.Native<
    ffi.Void Function(ffi.Pointer<SherpaOnnxOnlineRecognizer>,
        ffi.Pointer<SherpaOnnxOnlineStream>)>()
external void SherpaOnnxOnlineStreamReset(
  ffi.Pointer<SherpaOnnxOnlineRecognizer> recognizer,
  ffi.Pointer<SherpaOnnxOnlineStream> stream,
);

/// Signal that no more audio samples would be available.
/// After this call, you cannot call SherpaOnnxOnlineStreamAcceptWaveform() any
/// more.
///
/// @param stream A pointer returned by SherpaOnnxCreateOnlineStream()
@ffi.Native<ffi.Void Function(ffi.Pointer<SherpaOnnxOnlineStream>)>()
external void SherpaOnnxOnlineStreamInputFinished(
  ffi.Pointer<SherpaOnnxOnlineStream> stream,
);

/// Return 1 if an endpoint has been detected.
///
/// @param recognizer A pointer returned by SherpaOnnxCreateOnlineRecognizer()
/// @param stream A pointer returned by SherpaOnnxCreateOnlineStream()
/// @return Return 1 if an endpoint is detected. Return 0 otherwise.
@ffi.Native<
    ffi.Int32 Function(ffi.Pointer<SherpaOnnxOnlineRecognizer>,
        ffi.Pointer<SherpaOnnxOnlineStream>)>()
external int SherpaOnnxOnlineStreamIsEndpoint(
  ffi.Pointer<SherpaOnnxOnlineRecognizer> recognizer,
  ffi.Pointer<SherpaOnnxOnlineStream> stream,
);

/// Create a display object. Must be freed using SherpaOnnxDestroyDisplay to
/// avoid memory leak.
@ffi.Native<ffi.Pointer<SherpaOnnxDisplay> Function(ffi.Int32)>()
external ffi.Pointer<SherpaOnnxDisplay> SherpaOnnxCreateDisplay(
  int max_word_per_line,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<SherpaOnnxDisplay>)>()
external void SherpaOnnxDestroyDisplay(
  ffi.Pointer<SherpaOnnxDisplay> display,
);

/// Print the result.
@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<SherpaOnnxDisplay>, ffi.Int32, ffi.Pointer<ffi.Char>)>()
external void SherpaOnnxPrint(
  ffi.Pointer<SherpaOnnxDisplay> display,
  int idx,
  ffi.Pointer<ffi.Char> s,
);

/// @param config  Config for the recognizer.
/// @return Return a pointer to the recognizer. The user has to invoke
/// SherpaOnnxDestroyOfflineRecognizer() to free it to avoid memory
/// leak.
@ffi.Native<
    ffi.Pointer<SherpaOnnxOfflineRecognizer> Function(
        ffi.Pointer<SherpaOnnxOfflineRecognizerConfig>)>()
external ffi.Pointer<SherpaOnnxOfflineRecognizer>
    SherpaOnnxCreateOfflineRecognizer(
  ffi.Pointer<SherpaOnnxOfflineRecognizerConfig> config,
);

/// @param config  Config for the recognizer.
@ffi.Native<
    ffi.Void Function(ffi.Pointer<SherpaOnnxOfflineRecognizer>,
        ffi.Pointer<SherpaOnnxOfflineRecognizerConfig>)>()
external void SherpaOnnxOfflineRecognizerSetConfig(
  ffi.Pointer<SherpaOnnxOfflineRecognizer> recognizer,
  ffi.Pointer<SherpaOnnxOfflineRecognizerConfig> config,
);

/// Free a pointer returned by SherpaOnnxCreateOfflineRecognizer()
///
/// @param p A pointer returned by SherpaOnnxCreateOfflineRecognizer()
@ffi.Native<ffi.Void Function(ffi.Pointer<SherpaOnnxOfflineRecognizer>)>()
external void SherpaOnnxDestroyOfflineRecognizer(
  ffi.Pointer<SherpaOnnxOfflineRecognizer> recognizer,
);

/// Create an offline stream for accepting wave samples.
///
/// @param recognizer  A pointer returned by SherpaOnnxCreateOfflineRecognizer()
/// @return Return a pointer to an OfflineStream. The user has to invoke
/// SherpaOnnxDestroyOfflineStream() to free it to avoid memory leak.
@ffi.Native<
    ffi.Pointer<SherpaOnnxOfflineStream> Function(
        ffi.Pointer<SherpaOnnxOfflineRecognizer>)>()
external ffi.Pointer<SherpaOnnxOfflineStream> SherpaOnnxCreateOfflineStream(
  ffi.Pointer<SherpaOnnxOfflineRecognizer> recognizer,
);

/// Create an offline stream for accepting wave samples with the specified hot
/// words.
///
/// @param recognizer  A pointer returned by SherpaOnnxCreateOfflineRecognizer()
/// @return Return a pointer to an OfflineStream. The user has to invoke
/// SherpaOnnxDestroyOfflineStream() to free it to avoid memory leak.
@ffi.Native<
    ffi.Pointer<SherpaOnnxOfflineStream> Function(
        ffi.Pointer<SherpaOnnxOfflineRecognizer>, ffi.Pointer<ffi.Char>)>()
external ffi.Pointer<SherpaOnnxOfflineStream>
    SherpaOnnxCreateOfflineStreamWithHotwords(
  ffi.Pointer<SherpaOnnxOfflineRecognizer> recognizer,
  ffi.Pointer<ffi.Char> hotwords,
);

/// Destroy an offline stream.
///
/// @param stream A pointer returned by SherpaOnnxCreateOfflineStream()
@ffi.Native<ffi.Void Function(ffi.Pointer<SherpaOnnxOfflineStream>)>()
external void SherpaOnnxDestroyOfflineStream(
  ffi.Pointer<SherpaOnnxOfflineStream> stream,
);

/// Accept input audio samples and compute the features.
/// The user has to invoke SherpaOnnxDecodeOfflineStream() to run the neural
/// network and decoding.
///
/// @param stream  A pointer returned by SherpaOnnxCreateOfflineStream().
/// @param sample_rate  Sample rate of the input samples. If it is different
/// from config.feat_config.sample_rate, we will do
/// resampling inside sherpa-onnx.
/// @param samples A pointer to a 1-D array containing audio samples.
/// The range of samples has to be normalized to [-1, 1].
/// @param n  Number of elements in the samples array.
///
/// @caution: For each offline stream, please invoke this function only once!
@ffi.Native<
    ffi.Void Function(ffi.Pointer<SherpaOnnxOfflineStream>, ffi.Int32,
        ffi.Pointer<ffi.Float>, ffi.Int32)>()
external void SherpaOnnxAcceptWaveformOffline(
  ffi.Pointer<SherpaOnnxOfflineStream> stream,
  int sample_rate,
  ffi.Pointer<ffi.Float> samples,
  int n,
);

/// Decode an offline stream.
///
/// We assume you have invoked SherpaOnnxAcceptWaveformOffline() for the given
/// stream before calling this function.
///
/// @param recognizer A pointer returned by SherpaOnnxCreateOfflineRecognizer().
/// @param stream A pointer returned by SherpaOnnxCreateOfflineStream()
@ffi.Native<
    ffi.Void Function(ffi.Pointer<SherpaOnnxOfflineRecognizer>,
        ffi.Pointer<SherpaOnnxOfflineStream>)>()
external void SherpaOnnxDecodeOfflineStream(
  ffi.Pointer<SherpaOnnxOfflineRecognizer> recognizer,
  ffi.Pointer<SherpaOnnxOfflineStream> stream,
);

/// Decode a list offline streams in parallel.
///
/// We assume you have invoked SherpaOnnxAcceptWaveformOffline() for each stream
/// before calling this function.
///
/// @param recognizer A pointer returned by SherpaOnnxCreateOfflineRecognizer().
/// @param streams A pointer pointer array containing pointers returned
/// by SherpaOnnxCreateOfflineStream().
/// @param n Number of entries in the given streams.
@ffi.Native<
    ffi.Void Function(ffi.Pointer<SherpaOnnxOfflineRecognizer>,
        ffi.Pointer<ffi.Pointer<SherpaOnnxOfflineStream>>, ffi.Int32)>()
external void SherpaOnnxDecodeMultipleOfflineStreams(
  ffi.Pointer<SherpaOnnxOfflineRecognizer> recognizer,
  ffi.Pointer<ffi.Pointer<SherpaOnnxOfflineStream>> streams,
  int n,
);

/// Get the result of the offline stream.
///
/// We assume you have called SherpaOnnxDecodeOfflineStream() or
/// SherpaOnnxDecodeMultipleOfflineStreams() with the given stream before
/// calling this function.
///
/// @param stream A pointer returned by SherpaOnnxCreateOfflineStream().
/// @return Return a pointer to the result. The user has to invoke
/// SherpaOnnxDestroyOnlineRecognizerResult() to free the returned
/// pointer to avoid memory leak.
@ffi.Native<
    ffi.Pointer<SherpaOnnxOfflineRecognizerResult> Function(
        ffi.Pointer<SherpaOnnxOfflineStream>)>()
external ffi.Pointer<SherpaOnnxOfflineRecognizerResult>
    SherpaOnnxGetOfflineStreamResult(
  ffi.Pointer<SherpaOnnxOfflineStream> stream,
);

/// Destroy the pointer returned by SherpaOnnxGetOfflineStreamResult().
///
/// @param r A pointer returned by SherpaOnnxGetOfflineStreamResult()
@ffi.Native<ffi.Void Function(ffi.Pointer<SherpaOnnxOfflineRecognizerResult>)>()
external void SherpaOnnxDestroyOfflineRecognizerResult(
  ffi.Pointer<SherpaOnnxOfflineRecognizerResult> r,
);

/// Return the result as a json string.
/// The user has to use SherpaOnnxDestroyOfflineStreamResultJson()
/// to free the returned pointer to avoid memory leak
@ffi.Native<
    ffi.Pointer<ffi.Char> Function(ffi.Pointer<SherpaOnnxOfflineStream>)>()
external ffi.Pointer<ffi.Char> SherpaOnnxGetOfflineStreamResultAsJson(
  ffi.Pointer<SherpaOnnxOfflineStream> stream,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<ffi.Char>)>()
external void SherpaOnnxDestroyOfflineStreamResultJson(
  ffi.Pointer<ffi.Char> s,
);

/// @param config  Config for the keyword spotter.
/// @return Return a pointer to the spotter. The user has to invoke
/// SherpaOnnxDestroyKeywordSpotter() to free it to avoid memory leak.
@ffi.Native<
    ffi.Pointer<SherpaOnnxKeywordSpotter> Function(
        ffi.Pointer<SherpaOnnxKeywordSpotterConfig>)>()
external ffi.Pointer<SherpaOnnxKeywordSpotter> SherpaOnnxCreateKeywordSpotter(
  ffi.Pointer<SherpaOnnxKeywordSpotterConfig> config,
);

/// Free a pointer returned by SherpaOnnxCreateKeywordSpotter()
///
/// @param p A pointer returned by SherpaOnnxCreateKeywordSpotter()
@ffi.Native<ffi.Void Function(ffi.Pointer<SherpaOnnxKeywordSpotter>)>()
external void SherpaOnnxDestroyKeywordSpotter(
  ffi.Pointer<SherpaOnnxKeywordSpotter> spotter,
);

/// Create an online stream for accepting wave samples.
///
/// @param spotter A pointer returned by SherpaOnnxCreateKeywordSpotter()
/// @return Return a pointer to an OnlineStream. The user has to invoke
/// SherpaOnnxDestroyOnlineStream() to free it to avoid memory leak.
@ffi.Native<
    ffi.Pointer<SherpaOnnxOnlineStream> Function(
        ffi.Pointer<SherpaOnnxKeywordSpotter>)>()
external ffi.Pointer<SherpaOnnxOnlineStream> SherpaOnnxCreateKeywordStream(
  ffi.Pointer<SherpaOnnxKeywordSpotter> spotter,
);

/// Create an online stream for accepting wave samples with the specified hot
/// words.
///
/// @param spotter A pointer returned by SherpaOnnxCreateKeywordSpotter()
/// @param keywords A pointer points to the keywords that you set
/// @return Return a pointer to an OnlineStream. The user has to invoke
/// SherpaOnnxDestroyOnlineStream() to free it to avoid memory leak.
@ffi.Native<
    ffi.Pointer<SherpaOnnxOnlineStream> Function(
        ffi.Pointer<SherpaOnnxKeywordSpotter>, ffi.Pointer<ffi.Char>)>()
external ffi.Pointer<SherpaOnnxOnlineStream>
    SherpaOnnxCreateKeywordStreamWithKeywords(
  ffi.Pointer<SherpaOnnxKeywordSpotter> spotter,
  ffi.Pointer<ffi.Char> keywords,
);

/// Return 1 if there are enough number of feature frames for decoding.
/// Return 0 otherwise.
///
/// @param spotter A pointer returned by SherpaOnnxCreateKeywordSpotter
/// @param stream  A pointer returned by SherpaOnnxCreateKeywordStream
@ffi.Native<
    ffi.Int32 Function(ffi.Pointer<SherpaOnnxKeywordSpotter>,
        ffi.Pointer<SherpaOnnxOnlineStream>)>()
external int SherpaOnnxIsKeywordStreamReady(
  ffi.Pointer<SherpaOnnxKeywordSpotter> spotter,
  ffi.Pointer<SherpaOnnxOnlineStream> stream,
);

/// Call this function to run the neural network model and decoding.
///
/// Precondition for this function: SherpaOnnxIsKeywordStreamReady() MUST
/// return 1.
@ffi.Native<
    ffi.Void Function(ffi.Pointer<SherpaOnnxKeywordSpotter>,
        ffi.Pointer<SherpaOnnxOnlineStream>)>()
external void SherpaOnnxDecodeKeywordStream(
  ffi.Pointer<SherpaOnnxKeywordSpotter> spotter,
  ffi.Pointer<SherpaOnnxOnlineStream> stream,
);

/// Please call it right after a keyword is detected
@ffi.Native<
    ffi.Void Function(ffi.Pointer<SherpaOnnxKeywordSpotter>,
        ffi.Pointer<SherpaOnnxOnlineStream>)>()
external void SherpaOnnxResetKeywordStream(
  ffi.Pointer<SherpaOnnxKeywordSpotter> spotter,
  ffi.Pointer<SherpaOnnxOnlineStream> stream,
);

/// This function is similar to SherpaOnnxDecodeKeywordStream(). It decodes
/// multiple OnlineStream in parallel.
///
/// Caution: The caller has to ensure each OnlineStream is ready, i.e.,
/// SherpaOnnxIsKeywordStreamReady() for that stream should return 1.
///
/// @param spotter A pointer returned by SherpaOnnxCreateKeywordSpotter()
/// @param streams  A pointer array containing pointers returned by
/// SherpaOnnxCreateKeywordStream()
/// @param n  Number of elements in the given streams array.
@ffi.Native<
    ffi.Void Function(ffi.Pointer<SherpaOnnxKeywordSpotter>,
        ffi.Pointer<ffi.Pointer<SherpaOnnxOnlineStream>>, ffi.Int32)>()
external void SherpaOnnxDecodeMultipleKeywordStreams(
  ffi.Pointer<SherpaOnnxKeywordSpotter> spotter,
  ffi.Pointer<ffi.Pointer<SherpaOnnxOnlineStream>> streams,
  int n,
);

/// Get the decoding results so far for an OnlineStream.
///
/// @param spotter A pointer returned by SherpaOnnxCreateKeywordSpotter().
/// @param stream A pointer returned by SherpaOnnxCreateKeywordStream().
/// @return A pointer containing the result. The user has to invoke
/// SherpaOnnxDestroyKeywordResult() to free the returned pointer to
/// avoid memory leak.
@ffi.Native<
    ffi.Pointer<SherpaOnnxKeywordResult> Function(
        ffi.Pointer<SherpaOnnxKeywordSpotter>,
        ffi.Pointer<SherpaOnnxOnlineStream>)>()
external ffi.Pointer<SherpaOnnxKeywordResult> SherpaOnnxGetKeywordResult(
  ffi.Pointer<SherpaOnnxKeywordSpotter> spotter,
  ffi.Pointer<SherpaOnnxOnlineStream> stream,
);

/// Destroy the pointer returned by SherpaOnnxGetKeywordResult().
///
/// @param r A pointer returned by SherpaOnnxGetKeywordResult()
@ffi.Native<ffi.Void Function(ffi.Pointer<SherpaOnnxKeywordResult>)>()
external void SherpaOnnxDestroyKeywordResult(
  ffi.Pointer<SherpaOnnxKeywordResult> r,
);

/// the user has to call SherpaOnnxFreeKeywordResultJson() to free the returned
/// pointer to avoid memory leak
@ffi.Native<
    ffi.Pointer<ffi.Char> Function(ffi.Pointer<SherpaOnnxKeywordSpotter>,
        ffi.Pointer<SherpaOnnxOnlineStream>)>()
external ffi.Pointer<ffi.Char> SherpaOnnxGetKeywordResultAsJson(
  ffi.Pointer<SherpaOnnxKeywordSpotter> spotter,
  ffi.Pointer<SherpaOnnxOnlineStream> stream,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<ffi.Char>)>()
external void SherpaOnnxFreeKeywordResultJson(
  ffi.Pointer<ffi.Char> s,
);

/// Return an instance of circular buffer. The user has to use
/// SherpaOnnxDestroyCircularBuffer() to free the returned pointer to avoid
/// memory leak.
@ffi.Native<ffi.Pointer<SherpaOnnxCircularBuffer> Function(ffi.Int32)>()
external ffi.Pointer<SherpaOnnxCircularBuffer> SherpaOnnxCreateCircularBuffer(
  int capacity,
);

/// Free the pointer returned by SherpaOnnxCreateCircularBuffer()
@ffi.Native<ffi.Void Function(ffi.Pointer<SherpaOnnxCircularBuffer>)>()
external void SherpaOnnxDestroyCircularBuffer(
  ffi.Pointer<SherpaOnnxCircularBuffer> buffer,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<SherpaOnnxCircularBuffer>,
        ffi.Pointer<ffi.Float>, ffi.Int32)>()
external void SherpaOnnxCircularBufferPush(
  ffi.Pointer<SherpaOnnxCircularBuffer> buffer,
  ffi.Pointer<ffi.Float> p,
  int n,
);

/// Return n samples starting at the given index.
///
/// Return a pointer to an array containing n samples starting at start_index.
/// The user has to use SherpaOnnxCircularBufferFree() to free the returned
/// pointer to avoid memory leak.
@ffi.Native<
    ffi.Pointer<ffi.Float> Function(
        ffi.Pointer<SherpaOnnxCircularBuffer>, ffi.Int32, ffi.Int32)>()
external ffi.Pointer<ffi.Float> SherpaOnnxCircularBufferGet(
  ffi.Pointer<SherpaOnnxCircularBuffer> buffer,
  int start_index,
  int n,
);

/// Free the pointer returned by SherpaOnnxCircularBufferGet().
@ffi.Native<ffi.Void Function(ffi.Pointer<ffi.Float>)>()
external void SherpaOnnxCircularBufferFree(
  ffi.Pointer<ffi.Float> p,
);

/// Remove n elements from the buffer
@ffi.Native<
    ffi.Void Function(ffi.Pointer<SherpaOnnxCircularBuffer>, ffi.Int32)>()
external void SherpaOnnxCircularBufferPop(
  ffi.Pointer<SherpaOnnxCircularBuffer> buffer,
  int n,
);

/// Return number of elements in the buffer.
@ffi.Native<ffi.Int32 Function(ffi.Pointer<SherpaOnnxCircularBuffer>)>()
external int SherpaOnnxCircularBufferSize(
  ffi.Pointer<SherpaOnnxCircularBuffer> buffer,
);

/// Return the head of the buffer. It's always non-decreasing until you
/// invoke SherpaOnnxCircularBufferReset() which resets head to 0.
@ffi.Native<ffi.Int32 Function(ffi.Pointer<SherpaOnnxCircularBuffer>)>()
external int SherpaOnnxCircularBufferHead(
  ffi.Pointer<SherpaOnnxCircularBuffer> buffer,
);

/// Clear all elements in the buffer
@ffi.Native<ffi.Void Function(ffi.Pointer<SherpaOnnxCircularBuffer>)>()
external void SherpaOnnxCircularBufferReset(
  ffi.Pointer<SherpaOnnxCircularBuffer> buffer,
);

/// Return an instance of VoiceActivityDetector.
/// The user has to use SherpaOnnxDestroyVoiceActivityDetector() to free
/// the returned pointer to avoid memory leak.
@ffi.Native<
    ffi.Pointer<SherpaOnnxVoiceActivityDetector> Function(
        ffi.Pointer<SherpaOnnxVadModelConfig>, ffi.Float)>()
external ffi.Pointer<SherpaOnnxVoiceActivityDetector>
    SherpaOnnxCreateVoiceActivityDetector(
  ffi.Pointer<SherpaOnnxVadModelConfig> config,
  double buffer_size_in_seconds,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<SherpaOnnxVoiceActivityDetector>)>()
external void SherpaOnnxDestroyVoiceActivityDetector(
  ffi.Pointer<SherpaOnnxVoiceActivityDetector> p,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<SherpaOnnxVoiceActivityDetector>,
        ffi.Pointer<ffi.Float>, ffi.Int32)>()
external void SherpaOnnxVoiceActivityDetectorAcceptWaveform(
  ffi.Pointer<SherpaOnnxVoiceActivityDetector> p,
  ffi.Pointer<ffi.Float> samples,
  int n,
);

/// Return 1 if there are no speech segments available.
/// Return 0 if there are speech segments.
@ffi.Native<ffi.Int32 Function(ffi.Pointer<SherpaOnnxVoiceActivityDetector>)>()
external int SherpaOnnxVoiceActivityDetectorEmpty(
  ffi.Pointer<SherpaOnnxVoiceActivityDetector> p,
);

/// Return 1 if there is voice detected.
/// Return 0 if voice is silent.
@ffi.Native<ffi.Int32 Function(ffi.Pointer<SherpaOnnxVoiceActivityDetector>)>()
external int SherpaOnnxVoiceActivityDetectorDetected(
  ffi.Pointer<SherpaOnnxVoiceActivityDetector> p,
);

/// Return the first speech segment.
/// It throws if SherpaOnnxVoiceActivityDetectorEmpty() returns 1.
@ffi.Native<ffi.Void Function(ffi.Pointer<SherpaOnnxVoiceActivityDetector>)>()
external void SherpaOnnxVoiceActivityDetectorPop(
  ffi.Pointer<SherpaOnnxVoiceActivityDetector> p,
);

/// Clear current speech segments.
@ffi.Native<ffi.Void Function(ffi.Pointer<SherpaOnnxVoiceActivityDetector>)>()
external void SherpaOnnxVoiceActivityDetectorClear(
  ffi.Pointer<SherpaOnnxVoiceActivityDetector> p,
);

/// Return the first speech segment.
/// The user has to use SherpaOnnxDestroySpeechSegment() to free the returned
/// pointer to avoid memory leak.
@ffi.Native<
    ffi.Pointer<SherpaOnnxSpeechSegment> Function(
        ffi.Pointer<SherpaOnnxVoiceActivityDetector>)>()
external ffi.Pointer<SherpaOnnxSpeechSegment>
    SherpaOnnxVoiceActivityDetectorFront(
  ffi.Pointer<SherpaOnnxVoiceActivityDetector> p,
);

/// Free the pointer returned SherpaOnnxVoiceActivityDetectorFront().
@ffi.Native<ffi.Void Function(ffi.Pointer<SherpaOnnxSpeechSegment>)>()
external void SherpaOnnxDestroySpeechSegment(
  ffi.Pointer<SherpaOnnxSpeechSegment> p,
);

/// Re-initialize the voice activity detector.
@ffi.Native<ffi.Void Function(ffi.Pointer<SherpaOnnxVoiceActivityDetector>)>()
external void SherpaOnnxVoiceActivityDetectorReset(
  ffi.Pointer<SherpaOnnxVoiceActivityDetector> p,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<SherpaOnnxVoiceActivityDetector>)>()
external void SherpaOnnxVoiceActivityDetectorFlush(
  ffi.Pointer<SherpaOnnxVoiceActivityDetector> p,
);

/// Create an instance of offline TTS. The user has to use DestroyOfflineTts()
/// to free the returned pointer to avoid memory leak.
@ffi.Native<
    ffi.Pointer<SherpaOnnxOfflineTts> Function(
        ffi.Pointer<SherpaOnnxOfflineTtsConfig>)>()
external ffi.Pointer<SherpaOnnxOfflineTts> SherpaOnnxCreateOfflineTts(
  ffi.Pointer<SherpaOnnxOfflineTtsConfig> config,
);

/// Free the pointer returned by SherpaOnnxCreateOfflineTts()
@ffi.Native<ffi.Void Function(ffi.Pointer<SherpaOnnxOfflineTts>)>()
external void SherpaOnnxDestroyOfflineTts(
  ffi.Pointer<SherpaOnnxOfflineTts> tts,
);

/// Return the sample rate of the current TTS object
@ffi.Native<ffi.Int32 Function(ffi.Pointer<SherpaOnnxOfflineTts>)>()
external int SherpaOnnxOfflineTtsSampleRate(
  ffi.Pointer<SherpaOnnxOfflineTts> tts,
);

/// Return the number of speakers of the current TTS object
@ffi.Native<ffi.Int32 Function(ffi.Pointer<SherpaOnnxOfflineTts>)>()
external int SherpaOnnxOfflineTtsNumSpeakers(
  ffi.Pointer<SherpaOnnxOfflineTts> tts,
);

/// Generate audio from the given text and speaker id (sid).
/// The user has to use SherpaOnnxDestroyOfflineTtsGeneratedAudio() to free the
/// returned pointer to avoid memory leak.
@ffi.Native<
    ffi.Pointer<SherpaOnnxGeneratedAudio> Function(
        ffi.Pointer<SherpaOnnxOfflineTts>,
        ffi.Pointer<ffi.Char>,
        ffi.Int32,
        ffi.Float)>()
external ffi.Pointer<SherpaOnnxGeneratedAudio> SherpaOnnxOfflineTtsGenerate(
  ffi.Pointer<SherpaOnnxOfflineTts> tts,
  ffi.Pointer<ffi.Char> text,
  int sid,
  double speed,
);

/// callback is called whenever SherpaOnnxOfflineTtsConfig.max_num_sentences
/// sentences have been processed. The pointer passed to the callback
/// is freed once the callback is returned. So the caller should not keep
/// a reference to it.
@ffi.Native<
    ffi.Pointer<SherpaOnnxGeneratedAudio> Function(
        ffi.Pointer<SherpaOnnxOfflineTts>,
        ffi.Pointer<ffi.Char>,
        ffi.Int32,
        ffi.Float,
        SherpaOnnxGeneratedAudioCallback)>()
external ffi.Pointer<SherpaOnnxGeneratedAudio>
    SherpaOnnxOfflineTtsGenerateWithCallback(
  ffi.Pointer<SherpaOnnxOfflineTts> tts,
  ffi.Pointer<ffi.Char> text,
  int sid,
  double speed,
  SherpaOnnxGeneratedAudioCallback callback,
);

@ffi.Native<
    ffi.Pointer<SherpaOnnxGeneratedAudio> Function(
        ffi.Pointer<SherpaOnnxOfflineTts>,
        ffi.Pointer<ffi.Char>,
        ffi.Int32,
        ffi.Float,
        SherpaOnnxGeneratedAudioProgressCallback)>()
external ffi.Pointer<SherpaOnnxGeneratedAudio>
    SherpaOnnxOfflineTtsGenerateWithProgressCallback(
  ffi.Pointer<SherpaOnnxOfflineTts> tts,
  ffi.Pointer<ffi.Char> text,
  int sid,
  double speed,
  SherpaOnnxGeneratedAudioProgressCallback callback,
);

@ffi.Native<
    ffi.Pointer<SherpaOnnxGeneratedAudio> Function(
        ffi.Pointer<SherpaOnnxOfflineTts>,
        ffi.Pointer<ffi.Char>,
        ffi.Int32,
        ffi.Float,
        SherpaOnnxGeneratedAudioProgressCallbackWithArg,
        ffi.Pointer<ffi.Void>)>()
external ffi.Pointer<SherpaOnnxGeneratedAudio>
    SherpaOnnxOfflineTtsGenerateWithProgressCallbackWithArg(
  ffi.Pointer<SherpaOnnxOfflineTts> tts,
  ffi.Pointer<ffi.Char> text,
  int sid,
  double speed,
  SherpaOnnxGeneratedAudioProgressCallbackWithArg callback,
  ffi.Pointer<ffi.Void> arg,
);

/// Same as SherpaOnnxGeneratedAudioCallback but you can pass an additional
/// `void* arg` to the callback.
@ffi.Native<
    ffi.Pointer<SherpaOnnxGeneratedAudio> Function(
        ffi.Pointer<SherpaOnnxOfflineTts>,
        ffi.Pointer<ffi.Char>,
        ffi.Int32,
        ffi.Float,
        SherpaOnnxGeneratedAudioCallbackWithArg,
        ffi.Pointer<ffi.Void>)>()
external ffi.Pointer<SherpaOnnxGeneratedAudio>
    SherpaOnnxOfflineTtsGenerateWithCallbackWithArg(
  ffi.Pointer<SherpaOnnxOfflineTts> tts,
  ffi.Pointer<ffi.Char> text,
  int sid,
  double speed,
  SherpaOnnxGeneratedAudioCallbackWithArg callback,
  ffi.Pointer<ffi.Void> arg,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<SherpaOnnxGeneratedAudio>)>()
external void SherpaOnnxDestroyOfflineTtsGeneratedAudio(
  ffi.Pointer<SherpaOnnxGeneratedAudio> p,
);

/// Write the generated audio to a wave file.
/// The saved wave file contains a single channel and has 16-bit samples.
///
/// Return 1 if the write succeeded; return 0 on failure.
@ffi.Native<
    ffi.Int32 Function(
        ffi.Pointer<ffi.Float>, ffi.Int32, ffi.Int32, ffi.Pointer<ffi.Char>)>()
external int SherpaOnnxWriteWave(
  ffi.Pointer<ffi.Float> samples,
  int n,
  int sample_rate,
  ffi.Pointer<ffi.Char> filename,
);

/// the amount of bytes needed to store a wave file which contains a
/// single channel and has 16-bit samples.
@ffi.Native<ffi.Int64 Function(ffi.Int32)>()
external int SherpaOnnxWaveFileSize(
  int n_samples,
);

/// Similar to SherpaOnnxWriteWave , it writes wave to allocated  buffer;
///
/// in some case (http tts api return wave binary file, server do not need to
/// write wave to fs)
@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<ffi.Float>, ffi.Int32, ffi.Int32, ffi.Pointer<ffi.Char>)>()
external void SherpaOnnxWriteWaveToBuffer(
  ffi.Pointer<ffi.Float> samples,
  int n,
  int sample_rate,
  ffi.Pointer<ffi.Char> buffer,
);

/// Return a NULL pointer on error. It supports only standard WAVE file.
/// Each sample should be 16-bit. It supports only single channel..
///
/// If the returned pointer is not NULL, the user has to invoke
/// SherpaOnnxFreeWave() to free the returned pointer to avoid memory leak.
@ffi.Native<ffi.Pointer<SherpaOnnxWave> Function(ffi.Pointer<ffi.Char>)>()
external ffi.Pointer<SherpaOnnxWave> SherpaOnnxReadWave(
  ffi.Pointer<ffi.Char> filename,
);

/// Similar to SherpaOnnxReadWave(), it has read the content of `filename`
/// into the array `data`.
///
/// If the returned pointer is not NULL, the user has to invoke
/// SherpaOnnxFreeWave() to free the returned pointer to avoid memory leak.
@ffi.Native<
    ffi.Pointer<SherpaOnnxWave> Function(ffi.Pointer<ffi.Char>, ffi.Int32)>()
external ffi.Pointer<SherpaOnnxWave> SherpaOnnxReadWaveFromBinaryData(
  ffi.Pointer<ffi.Char> data,
  int n,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<SherpaOnnxWave>)>()
external void SherpaOnnxFreeWave(
  ffi.Pointer<SherpaOnnxWave> wave,
);

/// Create an instance of SpokenLanguageIdentification.
/// The user has to invoke SherpaOnnxDestroySpokenLanguageIdentification()
/// to free the returned pointer to avoid memory leak.
@ffi.Native<
    ffi.Pointer<SherpaOnnxSpokenLanguageIdentification> Function(
        ffi.Pointer<SherpaOnnxSpokenLanguageIdentificationConfig>)>()
external ffi.Pointer<SherpaOnnxSpokenLanguageIdentification>
    SherpaOnnxCreateSpokenLanguageIdentification(
  ffi.Pointer<SherpaOnnxSpokenLanguageIdentificationConfig> config,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<SherpaOnnxSpokenLanguageIdentification>)>()
external void SherpaOnnxDestroySpokenLanguageIdentification(
  ffi.Pointer<SherpaOnnxSpokenLanguageIdentification> slid,
);

/// The user has to invoke SherpaOnnxDestroyOfflineStream()
/// to free the returned pointer to avoid memory leak
@ffi.Native<
    ffi.Pointer<SherpaOnnxOfflineStream> Function(
        ffi.Pointer<SherpaOnnxSpokenLanguageIdentification>)>()
external ffi.Pointer<SherpaOnnxOfflineStream>
    SherpaOnnxSpokenLanguageIdentificationCreateOfflineStream(
  ffi.Pointer<SherpaOnnxSpokenLanguageIdentification> slid,
);

/// The user has to invoke SherpaOnnxDestroySpokenLanguageIdentificationResult()
/// to free the returned pointer to avoid memory leak
@ffi.Native<
    ffi.Pointer<SherpaOnnxSpokenLanguageIdentificationResult> Function(
        ffi.Pointer<SherpaOnnxSpokenLanguageIdentification>,
        ffi.Pointer<SherpaOnnxOfflineStream>)>()
external ffi.Pointer<SherpaOnnxSpokenLanguageIdentificationResult>
    SherpaOnnxSpokenLanguageIdentificationCompute(
  ffi.Pointer<SherpaOnnxSpokenLanguageIdentification> slid,
  ffi.Pointer<SherpaOnnxOfflineStream> s,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<SherpaOnnxSpokenLanguageIdentificationResult>)>()
external void SherpaOnnxDestroySpokenLanguageIdentificationResult(
  ffi.Pointer<SherpaOnnxSpokenLanguageIdentificationResult> r,
);

/// The user has to invoke SherpaOnnxDestroySpeakerEmbeddingExtractor()
/// to free the returned pointer to avoid memory leak
@ffi.Native<
    ffi.Pointer<SherpaOnnxSpeakerEmbeddingExtractor> Function(
        ffi.Pointer<SherpaOnnxSpeakerEmbeddingExtractorConfig>)>()
external ffi.Pointer<SherpaOnnxSpeakerEmbeddingExtractor>
    SherpaOnnxCreateSpeakerEmbeddingExtractor(
  ffi.Pointer<SherpaOnnxSpeakerEmbeddingExtractorConfig> config,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<SherpaOnnxSpeakerEmbeddingExtractor>)>()
external void SherpaOnnxDestroySpeakerEmbeddingExtractor(
  ffi.Pointer<SherpaOnnxSpeakerEmbeddingExtractor> p,
);

@ffi.Native<
    ffi.Int32 Function(ffi.Pointer<SherpaOnnxSpeakerEmbeddingExtractor>)>()
external int SherpaOnnxSpeakerEmbeddingExtractorDim(
  ffi.Pointer<SherpaOnnxSpeakerEmbeddingExtractor> p,
);

/// The user has to invoke SherpaOnnxDestroyOnlineStream() to free the returned
/// pointer to avoid memory leak
@ffi.Native<
    ffi.Pointer<SherpaOnnxOnlineStream> Function(
        ffi.Pointer<SherpaOnnxSpeakerEmbeddingExtractor>)>()
external ffi.Pointer<SherpaOnnxOnlineStream>
    SherpaOnnxSpeakerEmbeddingExtractorCreateStream(
  ffi.Pointer<SherpaOnnxSpeakerEmbeddingExtractor> p,
);

/// Return 1 if the stream has enough feature frames for computing embeddings.
/// Return 0 otherwise.
@ffi.Native<
    ffi.Int32 Function(ffi.Pointer<SherpaOnnxSpeakerEmbeddingExtractor>,
        ffi.Pointer<SherpaOnnxOnlineStream>)>()
external int SherpaOnnxSpeakerEmbeddingExtractorIsReady(
  ffi.Pointer<SherpaOnnxSpeakerEmbeddingExtractor> p,
  ffi.Pointer<SherpaOnnxOnlineStream> s,
);

/// Compute the embedding of the stream.
///
/// @return Return a pointer pointing to an array containing the embedding.
/// The length of the array is `dim` as returned by
/// SherpaOnnxSpeakerEmbeddingExtractorDim(p)
///
/// The user has to invoke SherpaOnnxSpeakerEmbeddingExtractorDestroyEmbedding()
/// to free the returned pointer to avoid memory leak.
@ffi.Native<
    ffi.Pointer<ffi.Float> Function(
        ffi.Pointer<SherpaOnnxSpeakerEmbeddingExtractor>,
        ffi.Pointer<SherpaOnnxOnlineStream>)>()
external ffi.Pointer<ffi.Float>
    SherpaOnnxSpeakerEmbeddingExtractorComputeEmbedding(
  ffi.Pointer<SherpaOnnxSpeakerEmbeddingExtractor> p,
  ffi.Pointer<SherpaOnnxOnlineStream> s,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<ffi.Float>)>()
external void SherpaOnnxSpeakerEmbeddingExtractorDestroyEmbedding(
  ffi.Pointer<ffi.Float> v,
);

/// The user has to invoke SherpaOnnxDestroySpeakerEmbeddingManager()
/// to free the returned pointer to avoid memory leak
@ffi.Native<
    ffi.Pointer<SherpaOnnxSpeakerEmbeddingManager> Function(ffi.Int32)>()
external ffi.Pointer<SherpaOnnxSpeakerEmbeddingManager>
    SherpaOnnxCreateSpeakerEmbeddingManager(
  int dim,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<SherpaOnnxSpeakerEmbeddingManager>)>()
external void SherpaOnnxDestroySpeakerEmbeddingManager(
  ffi.Pointer<SherpaOnnxSpeakerEmbeddingManager> p,
);

/// Register the embedding of a user
///
/// @param name  The name of the user
/// @param p Pointer to an array containing the embeddings. The length of the
/// array must be equal to `dim` used to construct the manager `p`.
///
/// @return Return 1 if added successfully. Return 0 on error
@ffi.Native<
    ffi.Int32 Function(ffi.Pointer<SherpaOnnxSpeakerEmbeddingManager>,
        ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Float>)>()
external int SherpaOnnxSpeakerEmbeddingManagerAdd(
  ffi.Pointer<SherpaOnnxSpeakerEmbeddingManager> p,
  ffi.Pointer<ffi.Char> name,
  ffi.Pointer<ffi.Float> v,
);

/// @param v Pointer to an array of embeddings. If there are n embeddings, then
/// v[0] is the pointer to the 0-th array containing the embeddings
/// v[1] is the pointer to the 1-st array containing the embeddings
/// v[n-1] is the pointer to the last array containing the embeddings
/// v[n] is a NULL pointer
/// @return Return 1 if added successfully. Return 0 on error
@ffi.Native<
    ffi.Int32 Function(ffi.Pointer<SherpaOnnxSpeakerEmbeddingManager>,
        ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Float>>)>()
external int SherpaOnnxSpeakerEmbeddingManagerAddList(
  ffi.Pointer<SherpaOnnxSpeakerEmbeddingManager> p,
  ffi.Pointer<ffi.Char> name,
  ffi.Pointer<ffi.Pointer<ffi.Float>> v,
);

/// Similar to SherpaOnnxSpeakerEmbeddingManagerAddList() but the memory
/// is flattened.
///
/// The length of the input array should be `n * dim`.
///
/// @return Return 1 if added successfully. Return 0 on error
@ffi.Native<
    ffi.Int32 Function(ffi.Pointer<SherpaOnnxSpeakerEmbeddingManager>,
        ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Float>, ffi.Int32)>()
external int SherpaOnnxSpeakerEmbeddingManagerAddListFlattened(
  ffi.Pointer<SherpaOnnxSpeakerEmbeddingManager> p,
  ffi.Pointer<ffi.Char> name,
  ffi.Pointer<ffi.Float> v,
  int n,
);

/// Remove a user.
/// @param naem The name of the user to remove.
/// @return Return 1 if removed successfully; return 0 on error.
///
/// Note if the user does not exist, it also returns 0.
@ffi.Native<
    ffi.Int32 Function(ffi.Pointer<SherpaOnnxSpeakerEmbeddingManager>,
        ffi.Pointer<ffi.Char>)>()
external int SherpaOnnxSpeakerEmbeddingManagerRemove(
  ffi.Pointer<SherpaOnnxSpeakerEmbeddingManager> p,
  ffi.Pointer<ffi.Char> name,
);

/// Search if an existing users' embedding matches the given one.
///
/// @param p Pointer to an array containing the embedding. The dim
/// of the array must equal to `dim` used to construct the manager `p`.
/// @param threshold A value between 0 and 1. If the similarity score exceeds
/// this threshold, we say a match is found.
/// @return Returns the name of the user if found. Return NULL if not found.
/// If not NULL, the caller has to invoke
/// SherpaOnnxSpeakerEmbeddingManagerFreeSearch() to free the returned
/// pointer to avoid memory leak.
@ffi.Native<
    ffi.Pointer<ffi.Char> Function(
        ffi.Pointer<SherpaOnnxSpeakerEmbeddingManager>,
        ffi.Pointer<ffi.Float>,
        ffi.Float)>()
external ffi.Pointer<ffi.Char> SherpaOnnxSpeakerEmbeddingManagerSearch(
  ffi.Pointer<SherpaOnnxSpeakerEmbeddingManager> p,
  ffi.Pointer<ffi.Float> v,
  double threshold,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<ffi.Char>)>()
external void SherpaOnnxSpeakerEmbeddingManagerFreeSearch(
  ffi.Pointer<ffi.Char> name,
);

/// Get the best matching speakers whose embeddings match the given
/// embedding.
///
/// @param p Pointer to the SherpaOnnxSpeakerEmbeddingManager instance.
/// @param v Pointer to an array containing the embedding vector.
/// @param threshold Minimum similarity score required for a match (between 0 and
/// 1).
/// @param n Number of best matches to retrieve.
/// @return Returns a pointer to
/// SherpaOnnxSpeakerEmbeddingManagerBestMatchesResult
/// containing the best matches found. Returns NULL if no matches are
/// found. The caller is responsible for freeing the returned pointer
/// using SherpaOnnxSpeakerEmbeddingManagerFreeBestMatches() to
/// avoid memory leaks.
@ffi.Native<
    ffi.Pointer<SherpaOnnxSpeakerEmbeddingManagerBestMatchesResult> Function(
        ffi.Pointer<SherpaOnnxSpeakerEmbeddingManager>,
        ffi.Pointer<ffi.Float>,
        ffi.Float,
        ffi.Int32)>()
external ffi.Pointer<SherpaOnnxSpeakerEmbeddingManagerBestMatchesResult>
    SherpaOnnxSpeakerEmbeddingManagerGetBestMatches(
  ffi.Pointer<SherpaOnnxSpeakerEmbeddingManager> p,
  ffi.Pointer<ffi.Float> v,
  double threshold,
  int n,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<SherpaOnnxSpeakerEmbeddingManagerBestMatchesResult>)>()
external void SherpaOnnxSpeakerEmbeddingManagerFreeBestMatches(
  ffi.Pointer<SherpaOnnxSpeakerEmbeddingManagerBestMatchesResult> r,
);

/// Check whether the input embedding matches the embedding of the input
/// speaker.
///
/// It is for speaker verification.
///
/// @param name The target speaker name.
/// @param p The input embedding to check.
/// @param threshold A value between 0 and 1.
/// @return Return 1 if it matches. Otherwise, it returns 0.
@ffi.Native<
    ffi.Int32 Function(ffi.Pointer<SherpaOnnxSpeakerEmbeddingManager>,
        ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Float>, ffi.Float)>()
external int SherpaOnnxSpeakerEmbeddingManagerVerify(
  ffi.Pointer<SherpaOnnxSpeakerEmbeddingManager> p,
  ffi.Pointer<ffi.Char> name,
  ffi.Pointer<ffi.Float> v,
  double threshold,
);

/// Return 1 if the user with the name is in the manager.
/// Return 0 if the user does not exist.
@ffi.Native<
    ffi.Int32 Function(ffi.Pointer<SherpaOnnxSpeakerEmbeddingManager>,
        ffi.Pointer<ffi.Char>)>()
external int SherpaOnnxSpeakerEmbeddingManagerContains(
  ffi.Pointer<SherpaOnnxSpeakerEmbeddingManager> p,
  ffi.Pointer<ffi.Char> name,
);

/// Return number of speakers in the manager.
@ffi.Native<
    ffi.Int32 Function(ffi.Pointer<SherpaOnnxSpeakerEmbeddingManager>)>()
external int SherpaOnnxSpeakerEmbeddingManagerNumSpeakers(
  ffi.Pointer<SherpaOnnxSpeakerEmbeddingManager> p,
);

/// Return the name of all speakers in the manager.
///
/// @return Return an array of pointers `ans`. If there are n speakers, then
/// - ans[0] contains the name of the 0-th speaker
/// - ans[1] contains the name of the 1-st speaker
/// - ans[n-1] contains the name of the last speaker
/// - ans[n] is NULL
/// If there are no users at all, then ans[0] is NULL. In any case,
/// `ans` is not NULL.
///
/// Each name is NULL-terminated
///
/// The caller has to invoke SherpaOnnxSpeakerEmbeddingManagerFreeAllSpeakers()
/// to free the returned pointer to avoid memory leak.
@ffi.Native<
    ffi.Pointer<ffi.Pointer<ffi.Char>> Function(
        ffi.Pointer<SherpaOnnxSpeakerEmbeddingManager>)>()
external ffi.Pointer<ffi.Pointer<ffi.Char>>
    SherpaOnnxSpeakerEmbeddingManagerGetAllSpeakers(
  ffi.Pointer<SherpaOnnxSpeakerEmbeddingManager> p,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<ffi.Pointer<ffi.Char>>)>()
external void SherpaOnnxSpeakerEmbeddingManagerFreeAllSpeakers(
  ffi.Pointer<ffi.Pointer<ffi.Char>> names,
);

/// The user has to invoke
/// SherpaOnnxDestroyAudioTagging()
/// to free the returned pointer to avoid memory leak
@ffi.Native<
    ffi.Pointer<SherpaOnnxAudioTagging> Function(
        ffi.Pointer<SherpaOnnxAudioTaggingConfig>)>()
external ffi.Pointer<SherpaOnnxAudioTagging> SherpaOnnxCreateAudioTagging(
  ffi.Pointer<SherpaOnnxAudioTaggingConfig> config,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<SherpaOnnxAudioTagging>)>()
external void SherpaOnnxDestroyAudioTagging(
  ffi.Pointer<SherpaOnnxAudioTagging> tagger,
);

/// The user has to invoke SherpaOnnxDestroyOfflineStream()
/// to free the returned pointer to avoid memory leak
@ffi.Native<
    ffi.Pointer<SherpaOnnxOfflineStream> Function(
        ffi.Pointer<SherpaOnnxAudioTagging>)>()
external ffi.Pointer<SherpaOnnxOfflineStream>
    SherpaOnnxAudioTaggingCreateOfflineStream(
  ffi.Pointer<SherpaOnnxAudioTagging> tagger,
);

/// Return an array of pointers. The length of the array is top_k + 1.
/// If top_k is -1, then config.top_k is used, where config is the config
/// used to create the input tagger.
///
/// The ans[0]->prob has the largest probability among the array elements
/// The last element of the array is a null pointer
///
/// The user has to use SherpaOnnxAudioTaggingFreeResults()
/// to free the returned pointer to avoid memory leak
@ffi.Native<
    ffi.Pointer<ffi.Pointer<SherpaOnnxAudioEvent>> Function(
        ffi.Pointer<SherpaOnnxAudioTagging>,
        ffi.Pointer<SherpaOnnxOfflineStream>,
        ffi.Int32)>()
external ffi.Pointer<ffi.Pointer<SherpaOnnxAudioEvent>>
    SherpaOnnxAudioTaggingCompute(
  ffi.Pointer<SherpaOnnxAudioTagging> tagger,
  ffi.Pointer<SherpaOnnxOfflineStream> s,
  int top_k,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<ffi.Pointer<SherpaOnnxAudioEvent>>)>()
external void SherpaOnnxAudioTaggingFreeResults(
  ffi.Pointer<ffi.Pointer<SherpaOnnxAudioEvent>> p,
);

/// The user has to invoke SherpaOnnxDestroyOfflinePunctuation()
/// to free the returned pointer to avoid memory leak
@ffi.Native<
    ffi.Pointer<SherpaOnnxOfflinePunctuation> Function(
        ffi.Pointer<SherpaOnnxOfflinePunctuationConfig>)>()
external ffi.Pointer<SherpaOnnxOfflinePunctuation>
    SherpaOnnxCreateOfflinePunctuation(
  ffi.Pointer<SherpaOnnxOfflinePunctuationConfig> config,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<SherpaOnnxOfflinePunctuation>)>()
external void SherpaOnnxDestroyOfflinePunctuation(
  ffi.Pointer<SherpaOnnxOfflinePunctuation> punct,
);

/// Add punctuations to the input text.
/// The user has to invoke SherpaOfflinePunctuationFreeText()
/// to free the returned pointer to avoid memory leak
@ffi.Native<
    ffi.Pointer<ffi.Char> Function(
        ffi.Pointer<SherpaOnnxOfflinePunctuation>, ffi.Pointer<ffi.Char>)>()
external ffi.Pointer<ffi.Char> SherpaOfflinePunctuationAddPunct(
  ffi.Pointer<SherpaOnnxOfflinePunctuation> punct,
  ffi.Pointer<ffi.Char> text,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<ffi.Char>)>()
external void SherpaOfflinePunctuationFreeText(
  ffi.Pointer<ffi.Char> text,
);

/// Create an online punctuation processor. The user has to invoke
/// SherpaOnnxDestroyOnlinePunctuation() to free the returned pointer
/// to avoid memory leak
@ffi.Native<
    ffi.Pointer<SherpaOnnxOnlinePunctuation> Function(
        ffi.Pointer<SherpaOnnxOnlinePunctuationConfig>)>()
external ffi.Pointer<SherpaOnnxOnlinePunctuation>
    SherpaOnnxCreateOnlinePunctuation(
  ffi.Pointer<SherpaOnnxOnlinePunctuationConfig> config,
);

/// Free a pointer returned by SherpaOnnxCreateOnlinePunctuation()
@ffi.Native<ffi.Void Function(ffi.Pointer<SherpaOnnxOnlinePunctuation>)>()
external void SherpaOnnxDestroyOnlinePunctuation(
  ffi.Pointer<SherpaOnnxOnlinePunctuation> punctuation,
);

/// Add punctuations to the input text. The user has to invoke
/// SherpaOnnxOnlinePunctuationFreeText() to free the returned pointer
/// to avoid memory leak
@ffi.Native<
    ffi.Pointer<ffi.Char> Function(
        ffi.Pointer<SherpaOnnxOnlinePunctuation>, ffi.Pointer<ffi.Char>)>()
external ffi.Pointer<ffi.Char> SherpaOnnxOnlinePunctuationAddPunct(
  ffi.Pointer<SherpaOnnxOnlinePunctuation> punctuation,
  ffi.Pointer<ffi.Char> text,
);

/// Free a pointer returned by SherpaOnnxOnlinePunctuationAddPunct()
@ffi.Native<ffi.Void Function(ffi.Pointer<ffi.Char>)>()
external void SherpaOnnxOnlinePunctuationFreeText(
  ffi.Pointer<ffi.Char> text,
);

/// float min_freq = min(sampling_rate_in_hz, samp_rate_out_hz);
/// float lowpass_cutoff = 0.99 * 0.5 * min_freq;
/// int32_t lowpass_filter_width = 6;
///
/// You can set filter_cutoff_hz to lowpass_cutoff
/// sand set num_zeros to lowpass_filter_width
/// /
/// // The user has to invoke SherpaOnnxDestroyLinearResampler()
/// // to free the returned pointer to avoid memory leak
@ffi.Native<
    ffi.Pointer<SherpaOnnxLinearResampler> Function(
        ffi.Int32, ffi.Int32, ffi.Float, ffi.Int32)>()
external ffi.Pointer<SherpaOnnxLinearResampler> SherpaOnnxCreateLinearResampler(
  int samp_rate_in_hz,
  int samp_rate_out_hz,
  double filter_cutoff_hz,
  int num_zeros,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<SherpaOnnxLinearResampler>)>()
external void SherpaOnnxDestroyLinearResampler(
  ffi.Pointer<SherpaOnnxLinearResampler> p,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<SherpaOnnxLinearResampler>)>()
external void SherpaOnnxLinearResamplerReset(
  ffi.Pointer<SherpaOnnxLinearResampler> p,
);

/// The user has to invoke SherpaOnnxLinearResamplerResampleFree()
/// to free the returned pointer to avoid memory leak.
///
/// If this is the last segment, you can set flush to 1; otherwise, please
/// set flush to 0
@ffi.Native<
    ffi.Pointer<SherpaOnnxResampleOut> Function(
        ffi.Pointer<SherpaOnnxLinearResampler>,
        ffi.Pointer<ffi.Float>,
        ffi.Int32,
        ffi.Int32)>()
external ffi.Pointer<SherpaOnnxResampleOut> SherpaOnnxLinearResamplerResample(
  ffi.Pointer<SherpaOnnxLinearResampler> p,
  ffi.Pointer<ffi.Float> input,
  int input_dim,
  int flush,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<SherpaOnnxResampleOut>)>()
external void SherpaOnnxLinearResamplerResampleFree(
  ffi.Pointer<SherpaOnnxResampleOut> p,
);

@ffi.Native<ffi.Int32 Function(ffi.Pointer<SherpaOnnxLinearResampler>)>()
external int SherpaOnnxLinearResamplerResampleGetInputSampleRate(
  ffi.Pointer<SherpaOnnxLinearResampler> p,
);

@ffi.Native<ffi.Int32 Function(ffi.Pointer<SherpaOnnxLinearResampler>)>()
external int SherpaOnnxLinearResamplerResampleGetOutputSampleRate(
  ffi.Pointer<SherpaOnnxLinearResampler> p,
);

/// Return 1 if the file exists; return 0 if the file does not exist.
@ffi.Native<ffi.Int32 Function(ffi.Pointer<ffi.Char>)>()
external int SherpaOnnxFileExists(
  ffi.Pointer<ffi.Char> filename,
);

/// The users has to invoke SherpaOnnxDestroyOfflineSpeakerDiarization()
/// to free the returned pointer to avoid memory leak
@ffi.Native<
    ffi.Pointer<SherpaOnnxOfflineSpeakerDiarization> Function(
        ffi.Pointer<SherpaOnnxOfflineSpeakerDiarizationConfig>)>()
external ffi.Pointer<SherpaOnnxOfflineSpeakerDiarization>
    SherpaOnnxCreateOfflineSpeakerDiarization(
  ffi.Pointer<SherpaOnnxOfflineSpeakerDiarizationConfig> config,
);

/// Free the pointer returned by SherpaOnnxCreateOfflineSpeakerDiarization()
@ffi.Native<
    ffi.Void Function(ffi.Pointer<SherpaOnnxOfflineSpeakerDiarization>)>()
external void SherpaOnnxDestroyOfflineSpeakerDiarization(
  ffi.Pointer<SherpaOnnxOfflineSpeakerDiarization> sd,
);

/// Expected sample rate of the input audio samples
@ffi.Native<
    ffi.Int32 Function(ffi.Pointer<SherpaOnnxOfflineSpeakerDiarization>)>()
external int SherpaOnnxOfflineSpeakerDiarizationGetSampleRate(
  ffi.Pointer<SherpaOnnxOfflineSpeakerDiarization> sd,
);

/// Only config->clustering is used. All other fields are ignored
@ffi.Native<
    ffi.Void Function(ffi.Pointer<SherpaOnnxOfflineSpeakerDiarization>,
        ffi.Pointer<SherpaOnnxOfflineSpeakerDiarizationConfig>)>()
external void SherpaOnnxOfflineSpeakerDiarizationSetConfig(
  ffi.Pointer<SherpaOnnxOfflineSpeakerDiarization> sd,
  ffi.Pointer<SherpaOnnxOfflineSpeakerDiarizationConfig> config,
);

@ffi.Native<
    ffi.Int32 Function(
        ffi.Pointer<SherpaOnnxOfflineSpeakerDiarizationResult>)>()
external int SherpaOnnxOfflineSpeakerDiarizationResultGetNumSpeakers(
  ffi.Pointer<SherpaOnnxOfflineSpeakerDiarizationResult> r,
);

@ffi.Native<
    ffi.Int32 Function(
        ffi.Pointer<SherpaOnnxOfflineSpeakerDiarizationResult>)>()
external int SherpaOnnxOfflineSpeakerDiarizationResultGetNumSegments(
  ffi.Pointer<SherpaOnnxOfflineSpeakerDiarizationResult> r,
);

/// The user has to invoke SherpaOnnxOfflineSpeakerDiarizationDestroySegment()
/// to free the returned pointer to avoid memory leak.
///
/// The returned pointer is the start address of an array.
/// Number of entries in the array equals to the value
/// returned by SherpaOnnxOfflineSpeakerDiarizationResultGetNumSegments()
@ffi.Native<
    ffi.Pointer<SherpaOnnxOfflineSpeakerDiarizationSegment> Function(
        ffi.Pointer<SherpaOnnxOfflineSpeakerDiarizationResult>)>()
external ffi.Pointer<SherpaOnnxOfflineSpeakerDiarizationSegment>
    SherpaOnnxOfflineSpeakerDiarizationResultSortByStartTime(
  ffi.Pointer<SherpaOnnxOfflineSpeakerDiarizationResult> r,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<SherpaOnnxOfflineSpeakerDiarizationSegment>)>()
external void SherpaOnnxOfflineSpeakerDiarizationDestroySegment(
  ffi.Pointer<SherpaOnnxOfflineSpeakerDiarizationSegment> s,
);

/// The user has to invoke SherpaOnnxOfflineSpeakerDiarizationDestroyResult()
/// to free the returned pointer to avoid memory leak.
@ffi.Native<
    ffi.Pointer<SherpaOnnxOfflineSpeakerDiarizationResult> Function(
        ffi.Pointer<SherpaOnnxOfflineSpeakerDiarization>,
        ffi.Pointer<ffi.Float>,
        ffi.Int32)>()
external ffi.Pointer<SherpaOnnxOfflineSpeakerDiarizationResult>
    SherpaOnnxOfflineSpeakerDiarizationProcess(
  ffi.Pointer<SherpaOnnxOfflineSpeakerDiarization> sd,
  ffi.Pointer<ffi.Float> samples,
  int n,
);

/// The user has to invoke SherpaOnnxOfflineSpeakerDiarizationDestroyResult()
/// to free the returned pointer to avoid memory leak.
@ffi.Native<
    ffi.Pointer<SherpaOnnxOfflineSpeakerDiarizationResult> Function(
        ffi.Pointer<SherpaOnnxOfflineSpeakerDiarization>,
        ffi.Pointer<ffi.Float>,
        ffi.Int32,
        SherpaOnnxOfflineSpeakerDiarizationProgressCallback,
        ffi.Pointer<ffi.Void>)>()
external ffi.Pointer<SherpaOnnxOfflineSpeakerDiarizationResult>
    SherpaOnnxOfflineSpeakerDiarizationProcessWithCallback(
  ffi.Pointer<SherpaOnnxOfflineSpeakerDiarization> sd,
  ffi.Pointer<ffi.Float> samples,
  int n,
  SherpaOnnxOfflineSpeakerDiarizationProgressCallback callback,
  ffi.Pointer<ffi.Void> arg,
);

@ffi.Native<
    ffi.Pointer<SherpaOnnxOfflineSpeakerDiarizationResult> Function(
        ffi.Pointer<SherpaOnnxOfflineSpeakerDiarization>,
        ffi.Pointer<ffi.Float>,
        ffi.Int32,
        SherpaOnnxOfflineSpeakerDiarizationProgressCallbackNoArg)>()
external ffi.Pointer<SherpaOnnxOfflineSpeakerDiarizationResult>
    SherpaOnnxOfflineSpeakerDiarizationProcessWithCallbackNoArg(
  ffi.Pointer<SherpaOnnxOfflineSpeakerDiarization> sd,
  ffi.Pointer<ffi.Float> samples,
  int n,
  SherpaOnnxOfflineSpeakerDiarizationProgressCallbackNoArg callback,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<SherpaOnnxOfflineSpeakerDiarizationResult>)>()
external void SherpaOnnxOfflineSpeakerDiarizationDestroyResult(
  ffi.Pointer<SherpaOnnxOfflineSpeakerDiarizationResult> r,
);

/// The users has to invoke SherpaOnnxDestroyOfflineSpeechDenoiser()
/// to free the returned pointer to avoid memory leak
@ffi.Native<
    ffi.Pointer<SherpaOnnxOfflineSpeechDenoiser> Function(
        ffi.Pointer<SherpaOnnxOfflineSpeechDenoiserConfig>)>()
external ffi.Pointer<SherpaOnnxOfflineSpeechDenoiser>
    SherpaOnnxCreateOfflineSpeechDenoiser(
  ffi.Pointer<SherpaOnnxOfflineSpeechDenoiserConfig> config,
);

/// Free the pointer returned by SherpaOnnxCreateOfflineSpeechDenoiser()
@ffi.Native<ffi.Void Function(ffi.Pointer<SherpaOnnxOfflineSpeechDenoiser>)>()
external void SherpaOnnxDestroyOfflineSpeechDenoiser(
  ffi.Pointer<SherpaOnnxOfflineSpeechDenoiser> sd,
);

@ffi.Native<ffi.Int32 Function(ffi.Pointer<SherpaOnnxOfflineSpeechDenoiser>)>()
external int SherpaOnnxOfflineSpeechDenoiserGetSampleRate(
  ffi.Pointer<SherpaOnnxOfflineSpeechDenoiser> sd,
);

/// Run speech denosing on input samples
/// @param samples  A 1-D array containing the input audio samples. Each sample
/// should be in the range [-1, 1].
/// @param n  Number of samples
/// @param sample_rate Sample rate of the input samples
///
/// The user MUST use SherpaOnnxDestroyDenoisedAudio() to free the returned
/// pointer to avoid memory leak.
@ffi.Native<
    ffi.Pointer<SherpaOnnxDenoisedAudio> Function(
        ffi.Pointer<SherpaOnnxOfflineSpeechDenoiser>,
        ffi.Pointer<ffi.Float>,
        ffi.Int32,
        ffi.Int32)>()
external ffi.Pointer<SherpaOnnxDenoisedAudio>
    SherpaOnnxOfflineSpeechDenoiserRun(
  ffi.Pointer<SherpaOnnxOfflineSpeechDenoiser> sd,
  ffi.Pointer<ffi.Float> samples,
  int n,
  int sample_rate,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<SherpaOnnxDenoisedAudio>)>()
external void SherpaOnnxDestroyDenoisedAudio(
  ffi.Pointer<SherpaOnnxDenoisedAudio> p,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<ffi.Char>, ffi.Int32, ffi.Float)>()
external void unnu_tts(
  ffi.Pointer<ffi.Char> text,
  int sid,
  double speed,
);

@ffi.Native<ffi.Void Function(SherpaOnnxOfflineTtsConfig)>()
external void unnu_tts_init(
  SherpaOnnxOfflineTtsConfig config,
);

@ffi.Native<ffi.Void Function(SpeakingActivityCallback)>()
external void unnu_tts_set_speaking_callback(
  SpeakingActivityCallback speaking_callback,
);

@ffi.Native<ffi.Void Function()>()
external void unnu_tts_unset_speaking_callback();

@ffi.Native<ffi.Void Function(ffi.Bool)>()
external void unnu_tts_enable(
  bool enable,
);

@ffi.Native<ffi.Void Function(ffi.Bool)>()
external void unnu_tts_mute(
  bool mute,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<UnnuTTSBoolStruct_t>)>()
external void unnu_tts_free_bool(
  ffi.Pointer<UnnuTTSBoolStruct_t> ptr,
);

@ffi.Native<ffi.Bool Function()>()
external bool unnu_tts_is_supported();

@ffi.Native<ffi.Bool Function()>()
external bool unnu_tts_is_streaming();

@ffi.Native<ffi.Bool Function()>()
external bool unnu_tts_is_enabled();

@ffi.Native<ffi.Bool Function()>()
external bool unnu_tts_is_muted();

@ffi.Native<ffi.Bool Function()>()
external bool unnu_tts_is_speaking();

/// FFI_PLUGIN_EXPORT bool unnu_tts_stop();
@ffi.Native<ffi.Void Function()>()
external void unnu_tts_destroy();

typedef va_list = ffi.Pointer<ffi.Char>;
typedef ptrdiff_t = ffi.LongLong;
typedef Dartptrdiff_t = int;
typedef int_least8_t = ffi.SignedChar;
typedef Dartint_least8_t = int;
typedef int_least16_t = ffi.Short;
typedef Dartint_least16_t = int;
typedef int_least32_t = ffi.Int;
typedef Dartint_least32_t = int;
typedef int_least64_t = ffi.LongLong;
typedef Dartint_least64_t = int;
typedef uint_least8_t = ffi.UnsignedChar;
typedef Dartuint_least8_t = int;
typedef uint_least16_t = ffi.UnsignedShort;
typedef Dartuint_least16_t = int;
typedef uint_least32_t = ffi.UnsignedInt;
typedef Dartuint_least32_t = int;
typedef uint_least64_t = ffi.UnsignedLongLong;
typedef Dartuint_least64_t = int;
typedef int_fast8_t = ffi.SignedChar;
typedef Dartint_fast8_t = int;
typedef int_fast16_t = ffi.Int;
typedef Dartint_fast16_t = int;
typedef int_fast32_t = ffi.Int;
typedef Dartint_fast32_t = int;
typedef int_fast64_t = ffi.LongLong;
typedef Dartint_fast64_t = int;
typedef uint_fast8_t = ffi.UnsignedChar;
typedef Dartuint_fast8_t = int;
typedef uint_fast16_t = ffi.UnsignedInt;
typedef Dartuint_fast16_t = int;
typedef uint_fast32_t = ffi.UnsignedInt;
typedef Dartuint_fast32_t = int;
typedef uint_fast64_t = ffi.UnsignedLongLong;
typedef Dartuint_fast64_t = int;
typedef intmax_t = ffi.LongLong;
typedef Dartintmax_t = int;
typedef uintmax_t = ffi.UnsignedLongLong;
typedef Dartuintmax_t = int;

/// Please refer to
/// https://k2-fsa.github.io/sherpa/onnx/pretrained_models/index.html
/// to download pre-trained models. That is, you can find encoder-xxx.onnx
/// decoder-xxx.onnx, joiner-xxx.onnx, and tokens.txt for this struct
/// from there.
final class SherpaOnnxOnlineTransducerModelConfig extends ffi.Struct {
  external ffi.Pointer<ffi.Char> encoder;

  external ffi.Pointer<ffi.Char> decoder;

  external ffi.Pointer<ffi.Char> joiner;
}

/// please visit
/// https://k2-fsa.github.io/sherpa/onnx/pretrained_models/online-paraformer/index.html
/// to download pre-trained streaming paraformer models
final class SherpaOnnxOnlineParaformerModelConfig extends ffi.Struct {
  external ffi.Pointer<ffi.Char> encoder;

  external ffi.Pointer<ffi.Char> decoder;
}

/// Please visit
/// https://k2-fsa.github.io/sherpa/onnx/pretrained_models/online-ctc/zipformer-ctc-models.html#
/// to download pre-trained streaming zipformer2 ctc models
final class SherpaOnnxOnlineZipformer2CtcModelConfig extends ffi.Struct {
  external ffi.Pointer<ffi.Char> model;
}

final class SherpaOnnxOnlineModelConfig extends ffi.Struct {
  external SherpaOnnxOnlineTransducerModelConfig transducer;

  external SherpaOnnxOnlineParaformerModelConfig paraformer;

  external SherpaOnnxOnlineZipformer2CtcModelConfig zipformer2_ctc;

  external ffi.Pointer<ffi.Char> tokens;

  @ffi.Int32()
  external int num_threads;

  external ffi.Pointer<ffi.Char> provider;

  /// true to print debug information of the model
  @ffi.Int32()
  external int debug;

  external ffi.Pointer<ffi.Char> model_type;

  /// Valid values:
  /// - cjkchar
  /// - bpe
  /// - cjkchar+bpe
  external ffi.Pointer<ffi.Char> modeling_unit;

  external ffi.Pointer<ffi.Char> bpe_vocab;

  /// if non-null, loading the tokens from the buffer instead of from the
  /// "tokens" file
  external ffi.Pointer<ffi.Char> tokens_buf;

  /// byte size excluding the trailing '\0'
  @ffi.Int32()
  external int tokens_buf_size;
}

/// It expects 16 kHz 16-bit single channel wave format.
final class SherpaOnnxFeatureConfig extends ffi.Struct {
  /// Sample rate of the input data. MUST match the one expected
  /// by the model. For instance, it should be 16000 for models provided
  /// by us.
  @ffi.Int32()
  external int sample_rate;

  /// Feature dimension of the model.
  /// For instance, it should be 80 for models provided by us.
  @ffi.Int32()
  external int feature_dim;
}

final class SherpaOnnxOnlineCtcFstDecoderConfig extends ffi.Struct {
  external ffi.Pointer<ffi.Char> graph;

  @ffi.Int32()
  external int max_active;
}

final class SherpaOnnxHomophoneReplacerConfig extends ffi.Struct {
  external ffi.Pointer<ffi.Char> dict_dir;

  external ffi.Pointer<ffi.Char> lexicon;

  external ffi.Pointer<ffi.Char> rule_fsts;
}

final class SherpaOnnxOnlineRecognizerConfig extends ffi.Struct {
  external SherpaOnnxFeatureConfig feat_config;

  external SherpaOnnxOnlineModelConfig model_config;

  /// Possible values are: greedy_search, modified_beam_search
  external ffi.Pointer<ffi.Char> decoding_method;

  /// Used only when decoding_method is modified_beam_search
  /// Example value: 4
  @ffi.Int32()
  external int max_active_paths;

  /// 0 to disable endpoint detection.
  /// A non-zero value to enable endpoint detection.
  @ffi.Int32()
  external int enable_endpoint;

  /// An endpoint is detected if trailing silence in seconds is larger than
  /// this value even if nothing has been decoded.
  /// Used only when enable_endpoint is not 0.
  @ffi.Float()
  external double rule1_min_trailing_silence;

  /// An endpoint is detected if trailing silence in seconds is larger than
  /// this value after something that is not blank has been decoded.
  /// Used only when enable_endpoint is not 0.
  @ffi.Float()
  external double rule2_min_trailing_silence;

  /// An endpoint is detected if the utterance in seconds is larger than
  /// this value.
  /// Used only when enable_endpoint is not 0.
  @ffi.Float()
  external double rule3_min_utterance_length;

  /// Path to the hotwords.
  external ffi.Pointer<ffi.Char> hotwords_file;

  /// Bonus score for each token in hotwords.
  @ffi.Float()
  external double hotwords_score;

  external SherpaOnnxOnlineCtcFstDecoderConfig ctc_fst_decoder_config;

  external ffi.Pointer<ffi.Char> rule_fsts;

  external ffi.Pointer<ffi.Char> rule_fars;

  @ffi.Float()
  external double blank_penalty;

  /// if non-nullptr, loading the hotwords from the buffered string directly in
  external ffi.Pointer<ffi.Char> hotwords_buf;

  /// byte size excluding the tailing '\0'
  @ffi.Int32()
  external int hotwords_buf_size;

  external SherpaOnnxHomophoneReplacerConfig hr;
}

final class SherpaOnnxOnlineRecognizerResult extends ffi.Struct {
  /// Recognized text
  external ffi.Pointer<ffi.Char> text;

  /// Pointer to continuous memory which holds string based tokens
  /// which are separated by \0
  external ffi.Pointer<ffi.Char> tokens;

  /// a pointer array containing the address of the first item in tokens
  external ffi.Pointer<ffi.Pointer<ffi.Char>> tokens_arr;

  /// Pointer to continuous memory which holds timestamps
  ///
  /// Caution: If timestamp information is not available, this pointer is NULL.
  /// Please check whether it is NULL before you access it; otherwise, you would
  /// get segmentation fault.
  external ffi.Pointer<ffi.Float> timestamps;

  /// The number of tokens/timestamps in above pointer
  @ffi.Int32()
  external int count;

  /// Return a json string.
  ///
  /// The returned string contains:
  /// {
  /// "text": "The recognition result",
  /// "tokens": [x, x, x],
  /// "timestamps": [x, x, x],
  /// "segment": x,
  /// "start_time": x,
  /// "is_final": true|false
  /// }
  external ffi.Pointer<ffi.Char> json;
}

final class SherpaOnnxOnlineRecognizer extends ffi.Opaque {}

final class SherpaOnnxOnlineStream extends ffi.Opaque {}

final class SherpaOnnxDisplay extends ffi.Opaque {}

/// Please refer to
/// https://k2-fsa.github.io/sherpa/onnx/pretrained_models/index.html
/// to download pre-trained models. That is, you can find encoder-xxx.onnx
/// decoder-xxx.onnx, and joiner-xxx.onnx for this struct
/// from there.
final class SherpaOnnxOfflineTransducerModelConfig extends ffi.Struct {
  external ffi.Pointer<ffi.Char> encoder;

  external ffi.Pointer<ffi.Char> decoder;

  external ffi.Pointer<ffi.Char> joiner;
}

final class SherpaOnnxOfflineParaformerModelConfig extends ffi.Struct {
  external ffi.Pointer<ffi.Char> model;
}

final class SherpaOnnxOfflineNemoEncDecCtcModelConfig extends ffi.Struct {
  external ffi.Pointer<ffi.Char> model;
}

final class SherpaOnnxOfflineWhisperModelConfig extends ffi.Struct {
  external ffi.Pointer<ffi.Char> encoder;

  external ffi.Pointer<ffi.Char> decoder;

  external ffi.Pointer<ffi.Char> language;

  external ffi.Pointer<ffi.Char> task;

  @ffi.Int32()
  external int tail_paddings;
}

final class SherpaOnnxOfflineFireRedAsrModelConfig extends ffi.Struct {
  external ffi.Pointer<ffi.Char> encoder;

  external ffi.Pointer<ffi.Char> decoder;
}

final class SherpaOnnxOfflineMoonshineModelConfig extends ffi.Struct {
  external ffi.Pointer<ffi.Char> preprocessor;

  external ffi.Pointer<ffi.Char> encoder;

  external ffi.Pointer<ffi.Char> uncached_decoder;

  external ffi.Pointer<ffi.Char> cached_decoder;
}

final class SherpaOnnxOfflineTdnnModelConfig extends ffi.Struct {
  external ffi.Pointer<ffi.Char> model;
}

final class SherpaOnnxOfflineLMConfig extends ffi.Struct {
  external ffi.Pointer<ffi.Char> model;

  @ffi.Float()
  external double scale;
}

final class SherpaOnnxOfflineSenseVoiceModelConfig extends ffi.Struct {
  external ffi.Pointer<ffi.Char> model;

  external ffi.Pointer<ffi.Char> language;

  @ffi.Int32()
  external int use_itn;
}

final class SherpaOnnxOfflineDolphinModelConfig extends ffi.Struct {
  external ffi.Pointer<ffi.Char> model;
}

final class SherpaOnnxOfflineModelConfig extends ffi.Struct {
  external SherpaOnnxOfflineTransducerModelConfig transducer;

  external SherpaOnnxOfflineParaformerModelConfig paraformer;

  external SherpaOnnxOfflineNemoEncDecCtcModelConfig nemo_ctc;

  external SherpaOnnxOfflineWhisperModelConfig whisper;

  external SherpaOnnxOfflineTdnnModelConfig tdnn;

  external ffi.Pointer<ffi.Char> tokens;

  @ffi.Int32()
  external int num_threads;

  @ffi.Int32()
  external int debug;

  external ffi.Pointer<ffi.Char> provider;

  external ffi.Pointer<ffi.Char> model_type;

  /// Valid values:
  /// - cjkchar
  /// - bpe
  /// - cjkchar+bpe
  external ffi.Pointer<ffi.Char> modeling_unit;

  external ffi.Pointer<ffi.Char> bpe_vocab;

  external ffi.Pointer<ffi.Char> telespeech_ctc;

  external SherpaOnnxOfflineSenseVoiceModelConfig sense_voice;

  external SherpaOnnxOfflineMoonshineModelConfig moonshine;

  external SherpaOnnxOfflineFireRedAsrModelConfig fire_red_asr;

  external SherpaOnnxOfflineDolphinModelConfig dolphin;
}

final class SherpaOnnxOfflineRecognizerConfig extends ffi.Struct {
  external SherpaOnnxFeatureConfig feat_config;

  external SherpaOnnxOfflineModelConfig model_config;

  external SherpaOnnxOfflineLMConfig lm_config;

  external ffi.Pointer<ffi.Char> decoding_method;

  @ffi.Int32()
  external int max_active_paths;

  /// Path to the hotwords.
  external ffi.Pointer<ffi.Char> hotwords_file;

  /// Bonus score for each token in hotwords.
  @ffi.Float()
  external double hotwords_score;

  external ffi.Pointer<ffi.Char> rule_fsts;

  external ffi.Pointer<ffi.Char> rule_fars;

  @ffi.Float()
  external double blank_penalty;

  external SherpaOnnxHomophoneReplacerConfig hr;
}

final class SherpaOnnxOfflineRecognizer extends ffi.Opaque {}

final class SherpaOnnxOfflineStream extends ffi.Opaque {}

final class SherpaOnnxOfflineRecognizerResult extends ffi.Struct {
  external ffi.Pointer<ffi.Char> text;

  /// Pointer to continuous memory which holds timestamps
  ///
  /// It is NULL if the model does not support timestamps
  external ffi.Pointer<ffi.Float> timestamps;

  /// number of entries in timestamps
  @ffi.Int32()
  external int count;

  /// Pointer to continuous memory which holds string based tokens
  /// which are separated by \0
  external ffi.Pointer<ffi.Char> tokens;

  /// a pointer array containing the address of the first item in tokens
  external ffi.Pointer<ffi.Pointer<ffi.Char>> tokens_arr;

  /// Return a json string.
  ///
  /// The returned string contains:
  /// {
  /// "text": "The recognition result",
  /// "tokens": [x, x, x],
  /// "timestamps": [x, x, x],
  /// "segment": x,
  /// "start_time": x,
  /// "is_final": true|false
  /// }
  external ffi.Pointer<ffi.Char> json;

  /// return recognized language
  external ffi.Pointer<ffi.Char> lang;

  /// return emotion.
  external ffi.Pointer<ffi.Char> emotion;

  /// return event.
  external ffi.Pointer<ffi.Char> event;
}

/// ============================================================
/// For Keyword Spotter
/// ============================================================
final class SherpaOnnxKeywordResult extends ffi.Struct {
  /// The triggered keyword.
  /// For English, it consists of space separated words.
  /// For Chinese, it consists of Chinese words without spaces.
  /// Example 1: "hello world"
  /// Example 2: ""
  external ffi.Pointer<ffi.Char> keyword;

  /// Decoded results at the token level.
  /// For instance, for BPE-based models it consists of a list of BPE tokens.
  external ffi.Pointer<ffi.Char> tokens;

  external ffi.Pointer<ffi.Pointer<ffi.Char>> tokens_arr;

  @ffi.Int32()
  external int count;

  /// timestamps.size() == tokens.size()
  /// timestamps[i] records the time in seconds when tokens[i] is decoded.
  external ffi.Pointer<ffi.Float> timestamps;

  /// Starting time of this segment.
  /// When an endpoint is detected, it will change
  @ffi.Float()
  external double start_time;

  /// Return a json string.
  ///
  /// The returned string contains:
  /// {
  /// "keyword": "The triggered keyword",
  /// "tokens": [x, x, x],
  /// "timestamps": [x, x, x],
  /// "start_time": x,
  /// }
  external ffi.Pointer<ffi.Char> json;
}

final class SherpaOnnxKeywordSpotterConfig extends ffi.Struct {
  external SherpaOnnxFeatureConfig feat_config;

  external SherpaOnnxOnlineModelConfig model_config;

  @ffi.Int32()
  external int max_active_paths;

  @ffi.Int32()
  external int num_trailing_blanks;

  @ffi.Float()
  external double keywords_score;

  @ffi.Float()
  external double keywords_threshold;

  external ffi.Pointer<ffi.Char> keywords_file;

  /// if non-null, loading the keywords from the buffer instead of from the
  /// keywords_file
  external ffi.Pointer<ffi.Char> keywords_buf;

  /// byte size excluding the trailing '\0'
  @ffi.Int32()
  external int keywords_buf_size;
}

final class SherpaOnnxKeywordSpotter extends ffi.Opaque {}

/// ============================================================
/// For VAD
/// ============================================================
final class SherpaOnnxSileroVadModelConfig extends ffi.Struct {
  /// Path to the silero VAD model
  external ffi.Pointer<ffi.Char> model;

  /// threshold to classify a segment as speech
  ///
  /// If the predicted probability of a segment is larger than this
  /// value, then it is classified as speech.
  @ffi.Float()
  external double threshold;

  /// in seconds
  @ffi.Float()
  external double min_silence_duration;

  /// in seconds
  @ffi.Float()
  external double min_speech_duration;

  @ffi.Int32()
  external int window_size;

  /// If a speech segment is longer than this value, then we increase
  /// the threshold to 0.9. After finishing detecting the segment,
  /// the threshold value is reset to its original value.
  @ffi.Float()
  external double max_speech_duration;
}

final class SherpaOnnxVadModelConfig extends ffi.Struct {
  external SherpaOnnxSileroVadModelConfig silero_vad;

  @ffi.Int32()
  external int sample_rate;

  @ffi.Int32()
  external int num_threads;

  external ffi.Pointer<ffi.Char> provider;

  @ffi.Int32()
  external int debug;
}

final class SherpaOnnxCircularBuffer extends ffi.Opaque {}

final class SherpaOnnxSpeechSegment extends ffi.Struct {
  /// The start index in samples of this segment
  @ffi.Int32()
  external int start;

  /// pointer to the array containing the samples
  external ffi.Pointer<ffi.Float> samples;

  /// number of samples in this segment
  @ffi.Int32()
  external int n;
}

final class SherpaOnnxVoiceActivityDetector extends ffi.Opaque {}

/// ============================================================
/// For offline Text-to-Speech (i.e., non-streaming TTS)
/// ============================================================
final class SherpaOnnxOfflineTtsVitsModelConfig extends ffi.Struct {
  external ffi.Pointer<ffi.Char> model;

  external ffi.Pointer<ffi.Char> lexicon;

  external ffi.Pointer<ffi.Char> tokens;

  external ffi.Pointer<ffi.Char> data_dir;

  @ffi.Float()
  external double noise_scale;

  @ffi.Float()
  external double noise_scale_w;

  /// < 1, faster in speech speed; > 1, slower in speed
  @ffi.Float()
  external double length_scale;

  external ffi.Pointer<ffi.Char> dict_dir;
}

final class SherpaOnnxOfflineTtsMatchaModelConfig extends ffi.Struct {
  external ffi.Pointer<ffi.Char> acoustic_model;

  external ffi.Pointer<ffi.Char> vocoder;

  external ffi.Pointer<ffi.Char> lexicon;

  external ffi.Pointer<ffi.Char> tokens;

  external ffi.Pointer<ffi.Char> data_dir;

  @ffi.Float()
  external double noise_scale;

  /// < 1, faster in speech speed; > 1, slower in speed
  @ffi.Float()
  external double length_scale;

  external ffi.Pointer<ffi.Char> dict_dir;
}

final class SherpaOnnxOfflineTtsKokoroModelConfig extends ffi.Struct {
  external ffi.Pointer<ffi.Char> model;

  external ffi.Pointer<ffi.Char> voices;

  external ffi.Pointer<ffi.Char> tokens;

  external ffi.Pointer<ffi.Char> data_dir;

  /// < 1, faster in speech speed; > 1, slower in speed
  @ffi.Float()
  external double length_scale;

  external ffi.Pointer<ffi.Char> dict_dir;

  external ffi.Pointer<ffi.Char> lexicon;

  external ffi.Pointer<ffi.Char> lang;
}

final class SherpaOnnxOfflineTtsModelConfig extends ffi.Struct {
  external SherpaOnnxOfflineTtsVitsModelConfig vits;

  @ffi.Int32()
  external int num_threads;

  @ffi.Int32()
  external int debug;

  external ffi.Pointer<ffi.Char> provider;

  external SherpaOnnxOfflineTtsMatchaModelConfig matcha;

  external SherpaOnnxOfflineTtsKokoroModelConfig kokoro;
}

final class SherpaOnnxOfflineTtsConfig extends ffi.Struct {
  external SherpaOnnxOfflineTtsModelConfig model;

  external ffi.Pointer<ffi.Char> rule_fsts;

  @ffi.Int32()
  external int max_num_sentences;

  external ffi.Pointer<ffi.Char> rule_fars;

  @ffi.Float()
  external double silence_scale;
}

final class SherpaOnnxGeneratedAudio extends ffi.Struct {
  /// in the range [-1, 1]
  external ffi.Pointer<ffi.Float> samples;

  /// number of samples
  @ffi.Int32()
  external int n;

  @ffi.Int32()
  external int sample_rate;
}

typedef SherpaOnnxGeneratedAudioCallbackFunction = ffi.Int32 Function(
    ffi.Pointer<ffi.Float> samples, ffi.Int32 n);
typedef DartSherpaOnnxGeneratedAudioCallbackFunction = int Function(
    ffi.Pointer<ffi.Float> samples, int n);

/// If the callback returns 0, then it stops generating
/// If the callback returns 1, then it keeps generating
typedef SherpaOnnxGeneratedAudioCallback
    = ffi.Pointer<ffi.NativeFunction<SherpaOnnxGeneratedAudioCallbackFunction>>;
typedef SherpaOnnxGeneratedAudioCallbackWithArgFunction = ffi.Int32 Function(
    ffi.Pointer<ffi.Float> samples, ffi.Int32 n, ffi.Pointer<ffi.Void> arg);
typedef DartSherpaOnnxGeneratedAudioCallbackWithArgFunction = int Function(
    ffi.Pointer<ffi.Float> samples, int n, ffi.Pointer<ffi.Void> arg);
typedef SherpaOnnxGeneratedAudioCallbackWithArg = ffi.Pointer<
    ffi.NativeFunction<SherpaOnnxGeneratedAudioCallbackWithArgFunction>>;
typedef SherpaOnnxGeneratedAudioProgressCallbackFunction = ffi.Int32 Function(
    ffi.Pointer<ffi.Float> samples, ffi.Int32 n, ffi.Float p);
typedef DartSherpaOnnxGeneratedAudioProgressCallbackFunction = int Function(
    ffi.Pointer<ffi.Float> samples, int n, double p);
typedef SherpaOnnxGeneratedAudioProgressCallback = ffi.Pointer<
    ffi.NativeFunction<SherpaOnnxGeneratedAudioProgressCallbackFunction>>;
typedef SherpaOnnxGeneratedAudioProgressCallbackWithArgFunction
    = ffi.Int32 Function(ffi.Pointer<ffi.Float> samples, ffi.Int32 n,
        ffi.Float p, ffi.Pointer<ffi.Void> arg);
typedef DartSherpaOnnxGeneratedAudioProgressCallbackWithArgFunction
    = int Function(ffi.Pointer<ffi.Float> samples, int n, double p,
        ffi.Pointer<ffi.Void> arg);
typedef SherpaOnnxGeneratedAudioProgressCallbackWithArg = ffi.Pointer<
    ffi
    .NativeFunction<SherpaOnnxGeneratedAudioProgressCallbackWithArgFunction>>;

final class SherpaOnnxOfflineTts extends ffi.Opaque {}

final class SherpaOnnxWave extends ffi.Struct {
  /// samples normalized to the range [-1, 1]
  external ffi.Pointer<ffi.Float> samples;

  @ffi.Int32()
  external int sample_rate;

  @ffi.Int32()
  external int num_samples;
}

/// ============================================================
/// For spoken language identification
/// ============================================================
final class SherpaOnnxSpokenLanguageIdentificationWhisperConfig
    extends ffi.Struct {
  external ffi.Pointer<ffi.Char> encoder;

  external ffi.Pointer<ffi.Char> decoder;

  @ffi.Int32()
  external int tail_paddings;
}

final class SherpaOnnxSpokenLanguageIdentificationConfig extends ffi.Struct {
  external SherpaOnnxSpokenLanguageIdentificationWhisperConfig whisper;

  @ffi.Int32()
  external int num_threads;

  @ffi.Int32()
  external int debug;

  external ffi.Pointer<ffi.Char> provider;
}

final class SherpaOnnxSpokenLanguageIdentification extends ffi.Opaque {}

final class SherpaOnnxSpokenLanguageIdentificationResult extends ffi.Struct {
  /// en for English
  /// de for German
  /// zh for Chinese
  /// es for Spanish
  /// ...
  external ffi.Pointer<ffi.Char> lang;
}

/// ============================================================
/// For speaker embedding extraction
/// ============================================================
final class SherpaOnnxSpeakerEmbeddingExtractorConfig extends ffi.Struct {
  external ffi.Pointer<ffi.Char> model;

  @ffi.Int32()
  external int num_threads;

  @ffi.Int32()
  external int debug;

  external ffi.Pointer<ffi.Char> provider;
}

final class SherpaOnnxSpeakerEmbeddingExtractor extends ffi.Opaque {}

final class SherpaOnnxSpeakerEmbeddingManager extends ffi.Opaque {}

final class SherpaOnnxSpeakerEmbeddingManagerSpeakerMatch extends ffi.Struct {
  @ffi.Float()
  external double score;

  external ffi.Pointer<ffi.Char> name;
}

final class SherpaOnnxSpeakerEmbeddingManagerBestMatchesResult
    extends ffi.Struct {
  external ffi.Pointer<SherpaOnnxSpeakerEmbeddingManagerSpeakerMatch> matches;

  @ffi.Int32()
  external int count;
}

/// ============================================================
/// For audio tagging
/// ============================================================
final class SherpaOnnxOfflineZipformerAudioTaggingModelConfig
    extends ffi.Struct {
  external ffi.Pointer<ffi.Char> model;
}

final class SherpaOnnxAudioTaggingModelConfig extends ffi.Struct {
  external SherpaOnnxOfflineZipformerAudioTaggingModelConfig zipformer;

  external ffi.Pointer<ffi.Char> ced;

  @ffi.Int32()
  external int num_threads;

  /// true to print debug information of the model
  @ffi.Int32()
  external int debug;

  external ffi.Pointer<ffi.Char> provider;
}

final class SherpaOnnxAudioTaggingConfig extends ffi.Struct {
  external SherpaOnnxAudioTaggingModelConfig model;

  external ffi.Pointer<ffi.Char> labels;

  @ffi.Int32()
  external int top_k;
}

final class SherpaOnnxAudioEvent extends ffi.Struct {
  external ffi.Pointer<ffi.Char> name;

  @ffi.Int32()
  external int index;

  @ffi.Float()
  external double prob;
}

final class SherpaOnnxAudioTagging extends ffi.Opaque {}

/// ============================================================
/// For punctuation
/// ============================================================
final class SherpaOnnxOfflinePunctuationModelConfig extends ffi.Struct {
  external ffi.Pointer<ffi.Char> ct_transformer;

  @ffi.Int32()
  external int num_threads;

  /// true to print debug information of the model
  @ffi.Int32()
  external int debug;

  external ffi.Pointer<ffi.Char> provider;
}

final class SherpaOnnxOfflinePunctuationConfig extends ffi.Struct {
  external SherpaOnnxOfflinePunctuationModelConfig model;
}

final class SherpaOnnxOfflinePunctuation extends ffi.Opaque {}

final class SherpaOnnxOnlinePunctuationModelConfig extends ffi.Struct {
  external ffi.Pointer<ffi.Char> cnn_bilstm;

  external ffi.Pointer<ffi.Char> bpe_vocab;

  @ffi.Int32()
  external int num_threads;

  @ffi.Int32()
  external int debug;

  external ffi.Pointer<ffi.Char> provider;
}

final class SherpaOnnxOnlinePunctuationConfig extends ffi.Struct {
  external SherpaOnnxOnlinePunctuationModelConfig model;
}

final class SherpaOnnxOnlinePunctuation extends ffi.Opaque {}

final class SherpaOnnxLinearResampler extends ffi.Opaque {}

final class SherpaOnnxResampleOut extends ffi.Struct {
  external ffi.Pointer<ffi.Float> samples;

  @ffi.Int32()
  external int n;
}

/// =========================================================================
/// For offline speaker diarization (i.e., non-streaming speaker diarization)
/// =========================================================================
final class SherpaOnnxOfflineSpeakerSegmentationPyannoteModelConfig
    extends ffi.Struct {
  external ffi.Pointer<ffi.Char> model;
}

final class SherpaOnnxOfflineSpeakerSegmentationModelConfig extends ffi.Struct {
  external SherpaOnnxOfflineSpeakerSegmentationPyannoteModelConfig pyannote;

  /// 1
  @ffi.Int32()
  external int num_threads;

  /// false
  @ffi.Int32()
  external int debug;

  /// "cpu"
  external ffi.Pointer<ffi.Char> provider;
}

final class SherpaOnnxFastClusteringConfig extends ffi.Struct {
  /// If greater than 0, then threshold is ignored.
  ///
  /// We strongly recommend that you set it if you know the number of clusters
  /// in advance
  @ffi.Int32()
  external int num_clusters;

  /// distance threshold.
  ///
  /// The smaller, the more clusters it will generate.
  /// The larger, the fewer clusters it will generate.
  @ffi.Float()
  external double threshold;
}

final class SherpaOnnxOfflineSpeakerDiarizationConfig extends ffi.Struct {
  external SherpaOnnxOfflineSpeakerSegmentationModelConfig segmentation;

  external SherpaOnnxSpeakerEmbeddingExtractorConfig embedding;

  external SherpaOnnxFastClusteringConfig clustering;

  /// in seconds
  @ffi.Float()
  external double min_duration_on;

  /// in seconds
  @ffi.Float()
  external double min_duration_off;
}

final class SherpaOnnxOfflineSpeakerDiarization extends ffi.Opaque {}

final class SherpaOnnxOfflineSpeakerDiarizationResult extends ffi.Opaque {}

final class SherpaOnnxOfflineSpeakerDiarizationSegment extends ffi.Struct {
  @ffi.Float()
  external double start;

  @ffi.Float()
  external double end;

  @ffi.Int32()
  external int speaker;
}

typedef SherpaOnnxOfflineSpeakerDiarizationProgressCallbackFunction
    = ffi.Int32 Function(ffi.Int32 num_processed_chunks,
        ffi.Int32 num_total_chunks, ffi.Pointer<ffi.Void> arg);
typedef DartSherpaOnnxOfflineSpeakerDiarizationProgressCallbackFunction
    = int Function(int num_processed_chunks, int num_total_chunks,
        ffi.Pointer<ffi.Void> arg);
typedef SherpaOnnxOfflineSpeakerDiarizationProgressCallback = ffi.Pointer<
    ffi.NativeFunction<
        SherpaOnnxOfflineSpeakerDiarizationProgressCallbackFunction>>;
typedef SherpaOnnxOfflineSpeakerDiarizationProgressCallbackNoArgFunction
    = ffi.Int32 Function(
        ffi.Int32 num_processed_chunks, ffi.Int32 num_total_chunks);
typedef DartSherpaOnnxOfflineSpeakerDiarizationProgressCallbackNoArgFunction
    = int Function(int num_processed_chunks, int num_total_chunks);
typedef SherpaOnnxOfflineSpeakerDiarizationProgressCallbackNoArg = ffi.Pointer<
    ffi.NativeFunction<
        SherpaOnnxOfflineSpeakerDiarizationProgressCallbackNoArgFunction>>;

/// =========================================================================
/// For offline speech enhancement
/// =========================================================================
final class SherpaOnnxOfflineSpeechDenoiserGtcrnModelConfig extends ffi.Struct {
  external ffi.Pointer<ffi.Char> model;
}

final class SherpaOnnxOfflineSpeechDenoiserModelConfig extends ffi.Struct {
  external SherpaOnnxOfflineSpeechDenoiserGtcrnModelConfig gtcrn;

  @ffi.Int32()
  external int num_threads;

  /// true to print debug information of the model
  @ffi.Int32()
  external int debug;

  external ffi.Pointer<ffi.Char> provider;
}

final class SherpaOnnxOfflineSpeechDenoiserConfig extends ffi.Struct {
  external SherpaOnnxOfflineSpeechDenoiserModelConfig model;
}

final class SherpaOnnxOfflineSpeechDenoiser extends ffi.Opaque {}

final class SherpaOnnxDenoisedAudio extends ffi.Struct {
  /// in the range [-1, 1]
  external ffi.Pointer<ffi.Float> samples;

  /// number of samples
  @ffi.Int32()
  external int n;

  @ffi.Int32()
  external int sample_rate;
}

final class UnnuTTSBoolStruct extends ffi.Struct {
  @ffi.Bool()
  external bool value;
}

typedef UnnuTTSBoolStruct_t = UnnuTTSBoolStruct;
typedef SpeakingActivityCallbackFunction = ffi.Void Function(
    ffi.Pointer<UnnuTTSBoolStruct_t>);
typedef DartSpeakingActivityCallbackFunction = void Function(
    ffi.Pointer<UnnuTTSBoolStruct_t>);
typedef SpeakingActivityCallback
    = ffi.Pointer<ffi.NativeFunction<SpeakingActivityCallbackFunction>>;

/// Possible capture errors
enum AudioDeviceErrors {
  /// No error
  noError(0),

  /// The capture device has failed to initialize.
  initFailed(1),

  /// The capture device has not yet been initialized.
  notInited(2),

  /// Device not found
  deviceNotFound(3),

  /// Failed to start the device.
  failedToStartDevice(4),

  /// Failed to stop the device.
  failedToStopDevice(5),

  /// Failed to initialize wav recording / playback / buffer.
  failedToInitialize(6),

  /// Failed to start wav recording / playback.
  failedToStart(7),

  /// Failed to initialize wav recording / playback.
  failedToStop(8),

  /// Failed to initialize wav recording / playback.
  failedToAbort(9),

  /// Invalid arguments while initializing wav recording.
  invalidArgs(10),

  /// Failed to read from buffer
  failedToRead(11),

  /// Failed to write to buffer
  failedToWrite(12);

  final int value;
  const AudioDeviceErrors(this.value);

  static AudioDeviceErrors fromValue(int value) => switch (value) {
        0 => noError,
        1 => initFailed,
        2 => notInited,
        3 => deviceNotFound,
        4 => failedToStartDevice,
        5 => failedToStopDevice,
        6 => failedToInitialize,
        7 => failedToStart,
        8 => failedToStop,
        9 => failedToAbort,
        10 => invalidArgs,
        11 => failedToRead,
        12 => failedToWrite,
        _ => throw ArgumentError('Unknown value for AudioDeviceErrors: $value'),
      };
}

enum PCMFormat {
  pcm_u8(0),
  pcm_s16(1),
  pcm_s24(2),
  pcm_s32(3),
  pcm_f32(4);

  final int value;
  const PCMFormat(this.value);

  static PCMFormat fromValue(int value) => switch (value) {
        0 => pcm_u8,
        1 => pcm_s16,
        2 => pcm_s24,
        3 => pcm_s32,
        4 => pcm_f32,
        _ => throw ArgumentError('Unknown value for PCMFormat: $value'),
      };
}

const int _VCRT_COMPILER_PREPROCESSOR = 1;

const int _SAL_VERSION = 20;

const int __SAL_H_VERSION = 180000000;

const int _USE_DECLSPECS_FOR_SAL = 0;

const int _USE_ATTRIBUTES_FOR_SAL = 0;

const int _CRT_PACKING = 8;

const int _VCRUNTIME_DISABLED_WARNINGS = 4514;

const int _HAS_EXCEPTIONS = 1;

const int _WCHAR_T_DEFINED = 1;

const int NULL = 0;

const int _HAS_CXX17 = 0;

const int _HAS_CXX20 = 0;

const int _HAS_CXX23 = 0;

const int _HAS_CXX26 = 0;

const int _HAS_NODISCARD = 1;

const int INT8_MIN = -128;

const int INT16_MIN = -32768;

const int INT32_MIN = -2147483648;

const int INT64_MIN = -9223372036854775808;

const int INT8_MAX = 127;

const int INT16_MAX = 32767;

const int INT32_MAX = 2147483647;

const int INT64_MAX = 9223372036854775807;

const int UINT8_MAX = 255;

const int UINT16_MAX = 65535;

const int UINT32_MAX = 4294967295;

const int UINT64_MAX = -1;

const int INT_LEAST8_MIN = -128;

const int INT_LEAST16_MIN = -32768;

const int INT_LEAST32_MIN = -2147483648;

const int INT_LEAST64_MIN = -9223372036854775808;

const int INT_LEAST8_MAX = 127;

const int INT_LEAST16_MAX = 32767;

const int INT_LEAST32_MAX = 2147483647;

const int INT_LEAST64_MAX = 9223372036854775807;

const int UINT_LEAST8_MAX = 255;

const int UINT_LEAST16_MAX = 65535;

const int UINT_LEAST32_MAX = 4294967295;

const int UINT_LEAST64_MAX = -1;

const int INT_FAST8_MIN = -128;

const int INT_FAST16_MIN = -2147483648;

const int INT_FAST32_MIN = -2147483648;

const int INT_FAST64_MIN = -9223372036854775808;

const int INT_FAST8_MAX = 127;

const int INT_FAST16_MAX = 2147483647;

const int INT_FAST32_MAX = 2147483647;

const int INT_FAST64_MAX = 9223372036854775807;

const int UINT_FAST8_MAX = 255;

const int UINT_FAST16_MAX = 4294967295;

const int UINT_FAST32_MAX = 4294967295;

const int UINT_FAST64_MAX = -1;

const int INTPTR_MIN = -9223372036854775808;

const int INTPTR_MAX = 9223372036854775807;

const int UINTPTR_MAX = -1;

const int INTMAX_MIN = -9223372036854775808;

const int INTMAX_MAX = 9223372036854775807;

const int UINTMAX_MAX = -1;

const int PTRDIFF_MIN = -9223372036854775808;

const int PTRDIFF_MAX = 9223372036854775807;

const int SIZE_MAX = -1;

const int SIG_ATOMIC_MIN = -2147483648;

const int SIG_ATOMIC_MAX = 2147483647;

const int WCHAR_MIN = 0;

const int WCHAR_MAX = 65535;

const int WINT_MIN = 0;

const int WINT_MAX = 65535;

const int __bool_true_false_are_defined = 1;

const int false$ = 0;

const int true$ = 1;
